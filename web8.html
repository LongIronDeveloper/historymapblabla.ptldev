<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B·∫£n ƒê·ªì Chi·∫øn Thu·∫≠t - Tactical Editor v10 (Final Legend & Fix)</title>
    
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Merriweather:ital,wght@0,400;0,700;1,400&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'Roboto', sans-serif; background-color: #e0d5b0; }
        
        #map { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 360px; height: 100vh;
            color: #dcdcdc; padding: 15px; box-sizing: border-box;
            transition: transform 0.3s ease;
            position: absolute; z-index: 1000; left: 0; top: 0; background: #2b2b2b;
            overflow-y: auto; box-shadow: 4px 0 15px rgba(0,0,0,0.6);
            border-right: 3px solid #8b4513;
            display: flex; flex-direction: column; gap: 12px;
        }
        #sidebar.collapsed { transform: translateX(-370px); }

        h2 { margin: 0; font-family: 'Cinzel', serif; font-size: 22px; text-align: center; color: #f39c12; border-bottom: 2px solid #8b4513; padding-bottom: 10px; text-shadow: 1px 1px 2px black; letter-spacing: 1px; }
        h3 { margin: 0; border-bottom: 1px solid #555; padding-bottom: 5px; font-size: 14px; color: #f1c40f; text-transform: uppercase; letter-spacing: 1px; }

        .control-group { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; border: 1px solid #444; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 13px; color: #aaa; }
        
        input, select, button { width: 100%; margin-bottom: 8px; padding: 8px; border-radius: 4px; border: 1px solid #555; background: #3c3c3c; color: white; font-size: 13px; }
        input[type="checkbox"] { width: auto; margin-right: 5px; vertical-align: middle; }
        
        button.btn-action { background: #5d4037; font-weight: bold; border: 1px solid #8d6e63; cursor: pointer; color: #f1c40f; }
        button.btn-action:hover { background: #795548; }

        /* Icon Grid */
        .icon-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .icon-option { background: #4a3b32; border: 1px solid #6d4c41; padding: 8px; text-align: center; cursor: pointer; border-radius: 4px; }
        .icon-option.selected { background: #f1c40f; color: #2c3e50; border-color: #fff; box-shadow: 0 0 8px #f1c40f; }
        
        .help-box { font-size: 12px; color: #bdc3c7; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; line-height: 1.5; border-left: 3px solid #e74c3c; }
        .help-key { display: inline-block; background: #eee; color: #333; padding: 0 4px; border-radius: 2px; font-weight: bold; font-family: monospace; font-size: 10px; }

        .top-right-controls {
            position: absolute; top: 15px; right: 15px; display: flex; flex-direction: column; gap: 5px; z-index: 2000;
        }

        #toggle-btn, #label-toggle-btn {
            width: 36px; height: 36px; 
            background: #8b4513; color: white; border: 2px solid #d35400; cursor: pointer; border-radius: 4px;
            display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            position: relative; top: auto; right: auto;
        }
        #label-toggle-btn { background: #2c3e50; border-color: #34495e; }

        .timeline-table { width: 100%; font-size: 12px; border-collapse: collapse; }
        .timeline-table td { padding: 4px; border-bottom: 1px solid #444; vertical-align: middle; }
        .order-input { width: 40px; text-align: center; background: #222; border: 1px solid #555; color: #f1c40f; font-weight: bold; padding: 2px; margin: 0; }
        .name-input { width: 100%; background: transparent; border: none; color: #dcdcdc; font-family: inherit; }
        .name-input:focus { border-bottom: 1px solid #f1c40f; outline: none; }

        #floating-legend {
            position: absolute; bottom: 20px; right: 20px;
            width: 350px; /* TƒÉng chi·ªÅu r·ªông ƒë·ªÉ ch·ª©a text d√†i */
            max-height: 60vh;
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid #8b4513; border-radius: 5px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); z-index: 2000;
            overflow: hidden; 
            color: #333; font-family: 'Merriweather', serif;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            transform-origin: bottom right;
        }
        #floating-legend.minimized { transform: translateY(calc(100% - 36px)); }
        
        .legend-header {
            background: #8b4513; color: #f1c40f; padding: 10px; font-weight: bold;
            display: flex; justify-content: space-between; align-items: center; cursor: pointer;
            font-size: 13px; text-transform: uppercase; user-select: none;
        }
        .legend-body { padding: 5px; overflow-y: auto; max-height: calc(60vh - 40px); }
        .legend-row { display: flex; align-items: center; gap: 10px; padding: 6px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s; }
        .legend-row:hover { background: #f0e6d2; }
        .l-icon { width: 30px; text-align: center; display: flex; justify-content: center; align-items: center; }
        .l-text { flex: 1; font-size: 11px; line-height: 1.3; font-weight: bold; color: #555; }
        
        .map-feature i { filter: sepia(0.4) drop-shadow(0px 2px 2px rgba(0,0,0,0.8)); }
        .custom-text-marker { text-shadow: 1px 1px 0 #000; }
        .bend-popup { font-size: 11px; color: #333; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 9999;
        }
        .modal-content {
            background: white; padding: 20px; border-radius: 8px; width: 320px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); font-family: Arial, sans-serif;
        }
        .modal-content h3 { color: #d9534f; margin-top: 0; border-bottom: none; font-size: 18px; text-align: left; }
        .modal-buttons { margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px; }
        .btn-danger { background: #d9534f; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; width: auto; }
        .btn-secondary { background: #ccc; color: black; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; width: auto; }
        .selected-danger { outline: 3px dashed red !important; border-radius: 4px; box-shadow: 0 0 10px red; background: rgba(255, 0, 0, 0.2); }

        /* FIXED VISUAL EFFECTS */
        /* Important: Removed 'transform' & 'transition' from the marker class to fix the drifting bug */
        .feature-dimmed i {
            filter: grayscale(100%) brightness(0.3) opacity(0.4) !important;
            transition: filter 0.3s ease;
        }
    </style>
</head>
<body>

    <div class="top-right-controls">
        <button id="toggle-btn" onclick="toggleSidebar()" title="ƒê√≥ng/M·ªü B·∫£ng C√¥ng C·ª•"><i class="fas fa-bars"></i></button>
        <button id="label-toggle-btn" onclick="toggleMapLabels()" title="·∫®n/Hi·ªán T√™n ƒê·ªãa Danh"><i class="fas fa-font"></i></button>
    </div>

    <div id="sidebar">
        <h2>B·∫¢NG C√îNG C·ª§ V·∫º</h2>
        <div class="control-group">
            <h3><i class="fas fa-info-circle"></i> H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng</h3>
            <div class="help-box">
                <b>1. M≈©i T√™n:</b> Click t·∫°o ƒëi·ªÉm, click ƒë√∫p k·∫øt th√∫c. Gi·ªØ <span class="help-key">Z</span> di chu·ªôt ƒë·ªÉ b·∫ª cong.<br>
                <b>2. V√πng (N√©t v·∫Ω):</b> Gi·ªØ chu·ªôt tr√°i v√† di chuy·ªÉn. T√≠ch "T·ª± ƒë·ªông ƒë·ªï m√†u" ƒë·ªÉ t·∫°o v√πng k√≠n.<br>
                <b>3. Xoay (Icon/M≈©i t√™n):</b> Click ch·ªçn -> Nh·∫•n <span class="help-key">A</span> (Tr√°i) / <span class="help-key">D</span> (Ph·∫£i).<br>
                <b>4. G·ªôp nh√≥m:</b> S·ª≠a s·ªë th·ª© t·ª± trong b·∫£ng b√™n d∆∞·ªõi gi·ªëng nhau ƒë·ªÉ g·ªôp.<br>
                <b>5. Hi·ªáu ·ª©ng (U):</b> B·∫≠t ch·∫ø ƒë·ªô "L√†m t·ªëi" c√°c b∆∞·ªõc kh√¥ng ch·ªçn ƒë·ªÉ n·ªïi b·∫≠t b∆∞·ªõc hi·ªán t·∫°i.<br>
                <b style="color:#e74c3c;">6. X√≥a (X):</b> Ch·ªçn ƒë·ªëi t∆∞·ª£ng -> Nh·∫•n <span class="help-key">X</span>.
            </div>
        </div>

        <div class="control-group">
            <h3>C√¥ng C·ª• Chi·∫øn Thu·∫≠t</h3>
            <select id="draw-mode" onchange="updateUI()">
                <option value="none">-- Ch·ªçn Ch·∫ø ƒê·ªô --</option>
                <option value="arrow">M≈©i T√™n (Chi·∫øn d·ªãch)</option>
                <option value="marker">Bi·ªÉu T∆∞·ª£ng (Icon)</option>
                <option value="text">VƒÉn B·∫£n (Ghi ch√∫)</option>
                <option value="polygon">V√πng / N√©t v·∫Ω t·ª± do</option>
                <option value="delete" style="color: #e74c3c; font-weight: bold;">üóëÔ∏è Ch·∫ø ƒë·ªô X√≥a (Ph√≠m X)</option>
            </select>
            <button class="btn-action" id="action-btn" onclick="toggleDrawing()">B·∫Øt ƒë·∫ßu v·∫Ω</button>
        </div>

        <div id="options-panel">
            <div class="control-group">
                <label>Thu·ªôc t√≠nh chung:</label>
                <div style="display:flex; gap:5px; align-items:center; flex-wrap: wrap;">
                    <input type="color" id="draw-color" value="#c0392b" style="width:40px; height:30px; padding:0;">
                    <input type="number" id="draw-size" value="4" min="1" max="20" title="K√≠ch th∆∞·ªõc ƒë·∫ßu m≈©i t√™n/Icon" style="width:50px;" placeholder="Size">
                    <input type="number" id="draw-width" value="4" min="1" max="20" title="ƒê·ªô d√†y ƒë∆∞·ªùng th·∫≥ng" style="width:50px;" placeholder="D√†y">
                </div>
                <div id="arrow-specific-options" style="display:none; margin-top:5px;">
                     <label><input type="checkbox" id="draw-dashed"> N√©t ƒë·ª©t (R√∫t lui/B√≠ m·∫≠t)</label>
                </div>
                <div id="polygon-specific-options" style="display:none; margin-top:5px;">
                    <label><input type="checkbox" id="poly-fill" checked> T·ª± ƒë·ªông ƒë·ªï m√†u (Kh√©p k√≠n)</label>
                    <label><input type="checkbox" id="poly-dashed"> Vi·ªÅn n√©t ƒë·ª©t</label>
                </div>
                <input type="text" id="draw-label" placeholder="T√™n (Hi·ªÉn th·ªã trong timeline)..." style="margin-top:5px;">
            </div>

            <div class="control-group" id="icon-options" style="display:none;">
                <label>Bi·ªÉu t∆∞·ª£ng:</label>
                <div class="icon-grid">
                    <div class="icon-option selected" onclick="selectIcon('fire')" title="N∆°i kh·ªüi nghƒ©a"><i class="fas fa-fire" style="color:#e67e22"></i></div>
                    <div class="icon-option" onclick="selectIcon('flag')" title="S·ªü ch·ªâ huy"><i class="fas fa-flag" style="color:#c0392b"></i></div>
                    <div class="icon-option" onclick="selectIcon('star')" title="Chi·∫øn th·∫Øng"><i class="fas fa-star" style="color:#f1c40f"></i></div>
                    <div class="icon-option" onclick="selectIcon('chess-rook')" title="Th√†nh tr√¨"><i class="fas fa-chess-rook" style="color:#7f8c8d"></i></div>
                    <div class="icon-option" onclick="selectIcon('skull')" title="Ti√™u di·ªát"><i class="fas fa-skull" style="color:#fff"></i></div>
                    <div class="icon-option" onclick="selectIcon('campground')" title="Doanh tr·∫°i"><i class="fas fa-campground" style="color:#27ae60"></i></div>
                    
                    <div class="icon-option" onclick="selectIcon('mountain')" title="N√∫i/ƒê·ªãa h√¨nh"><i class="fas fa-mountain" style="color:#5d4037"></i></div>
                    <div class="icon-option" onclick="selectIcon('location-arrow')" title="Ch·∫∑n ƒë√°nh"><i class="fas fa-location-arrow" style="color:#c0392b"></i></div>
                    <div class="icon-option" onclick="selectIcon('times')" title="D·∫•u X (Di·ªát)"><i class="fas fa-times" style="color:#c0392b"></i></div>
                </div>
            </div>

            <div class="control-group" id="text-options" style="display:none;">
                <input type="text" id="text-content" placeholder="N·ªôi dung ch·ªØ...">
                <select id="text-font">
                    <option value="'Merriweather', serif">Merriweather (C·ªï ƒëi·ªÉn)</option>
                    <option value="'Roboto', sans-serif">Roboto (Hi·ªán ƒë·∫°i)</option>
                </select>
                <div style="display:flex; gap:10px;">
                    <label><input type="checkbox" id="text-bold" checked> ƒê·∫≠m</label>
                    <label><input type="checkbox" id="text-italic"> Nghi√™ng</label>
                </div>
            </div>
        </div>

        <div class="control-group">
            <h3>Di·ªÖn Bi·∫øn (Timeline)</h3>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                <span id="current-step-display" style="font-size:13px; font-weight:bold; color:#f1c40f;">Hi·ªán t·∫•t c·∫£</span>
                <div style="display:flex; gap: 2px;">
                    <button onclick="changeTimeline(-1)" style="width:30px; margin:0;" title="L√πi (Y)">Y</button>
                    <button onclick="changeTimeline(1)" style="width:30px; margin:0;" title="Ti·∫øn (T)">T</button>
                    <button onclick="showAllTimeline()" style="width:30px; margin:0; background:#f39c12; color:#000;" title="Hi·ªán t·∫•t c·∫£ (M·∫Øt)"><i class="fas fa-eye"></i></button>
                </div>
            </div>
            <label style="font-size:11px; color:#aaa; margin-top:4px;">
                <input type="checkbox" id="chk-glow-effect" onchange="toggleGlowMode()"> B·∫≠t ch·∫ø ƒë·ªô L√†m t·ªëi (·∫®n c√°c b∆∞·ªõc kh√°c) - Ph√≠m U
            </label>
            <div style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2);">
                <table class="timeline-table">
                    <thead>
                        <tr style="color:#aaa; border-bottom:1px solid #555;">
                            <th align="center" width="40">STT</th>
                            <th align="left">T√™n (S·ª≠a ƒë∆∞·ª£c)</th>
                            <th width="30">X√≥a</th>
                        </tr>
                    </thead>
                    <tbody id="timeline-list"></tbody>
                </table>
            </div>
        </div>
        
        <div class="control-group" style="margin-top:auto;">
             <button class="btn-action" onclick="exportJSON()">L∆∞u B·∫£n ƒê·ªì (JSON)</button>
             <input type="file" id="file-input" style="display: none;" onchange="importJSON(this)">
             <button class="btn-action" style="background:#333; margin-top:5px;" onclick="document.getElementById('file-input').click()">M·ªü B·∫£n ƒê·ªì</button>
        </div>
    </div>

    <div id="floating-legend">
        <div class="legend-header" onclick="toggleLegend()">
            <span><i class="fas fa-map"></i> Ch√∫ Gi·∫£i Qu√¢n S·ª±</span>
            <i class="fas fa-chevron-down" id="legend-icon"></i>
        </div>
        <div class="legend-body" id="static-legend-container"></div>
    </div>

    <div id="map"></div>

    <div id="delete-confirm-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3>‚ö†Ô∏è X√°c nh·∫≠n x√≥a</h3>
            <p>B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ƒë·ªëi t∆∞·ª£ng ƒëang ch·ªçn kh√¥ng?</p>
            <label style="display:block; margin: 10px 0; font-size: 13px; color:#555;">
                <input type="checkbox" id="chk-no-remind"> Kh√¥ng nh·∫Øc l·∫°i
            </label>
            <div class="modal-buttons">
                <button id="btn-confirm-delete" class="btn-danger">X√≥a (X)</button>
                <button id="btn-cancel-delete" class="btn-secondary">H·ªßy (Esc)</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIG & INIT ---
        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://demotiles.maplibre.org/style.json', 
            center: [105.4, 19.3], 
            zoom: 7.2, pitch: 0, antialias: true
        });

        let mapData = { features: [] };
        let isDrawing = false;
        let isFreehandDrawing = false;
        let currentDrawType = 'none';
        let currentPoints = [];
        let tempId = 'temp-layer';
        
        let selectedIcon = 'fire';
        
        let selectedRotatable = null; 
        let selectedLineId = null; 
        let isBending = false;

        let currentTimelineStep = 999;
        let arrowCounter = 0;
        let pendingDeleteId = null; 
        let suppressDeleteWarning = false; 
        
        let isGlowingEnabled = false;

        map.on('load', () => {
            map.addSource('vietnam-border', { type: 'geojson', data: 'https://raw.githubusercontent.com/vietnam-geospatial/vietnam-administrative-boundaries/master/vietnam_boundary.geojson' });
            map.addLayer({ id: 'vn-border-halo', type: 'line', source: 'vietnam-border', paint: { 'line-color': '#f1c40f', 'line-width': 6, 'line-opacity': 0.4 } });
            map.addLayer({ id: 'vn-border-line', type: 'line', source: 'vietnam-border', paint: { 'line-color': '#8b4513', 'line-width': 2 } });
            createStaticLegend();
        });

        // --- INTERACTION ---
        function toggleDrawing() {
            isDrawing = !isDrawing;
            const btn = document.getElementById('action-btn');
            currentDrawType = document.getElementById('draw-mode').value;
            
            if(currentDrawType === 'delete') {
                isDrawing = true; 
                btn.innerText = "THO√ÅT CH·∫æ ƒê·ªò X√ìA (ESC)"; btn.style.background = "#d35400"; btn.style.color = "white";
                map.getCanvas().style.cursor = 'not-allowed'; 
                clearDeleteSelection(); 
            }
            else if(isDrawing) {
                if (currentDrawType === 'polygon') {
                    btn.innerText = "D·ª™NG V·∫º (Th·∫£ chu·ªôt)"; 
                    map.getCanvas().style.cursor = 'crosshair';
                    map.dragPan.disable();
                } else {
                    btn.innerText = "D·ª™NG V·∫º (ESC)"; 
                    map.getCanvas().style.cursor = 'crosshair';
                    map.dragPan.enable();
                }
                btn.style.background = "#c0392b"; btn.style.color = "white";
            } else {
                stopDrawing();
            }
        }

        function stopDrawing() {
            isDrawing = false; isFreehandDrawing = false; currentPoints = [];
            const btn = document.getElementById('action-btn');
            btn.innerText = "B·∫Øt ƒë·∫ßu v·∫Ω"; btn.style.background = "#5d4037"; btn.style.color = "#f1c40f";
            map.getCanvas().style.cursor = '';
            map.dragPan.enable();
            if(map.getLayer(tempId)) map.removeLayer(tempId);
            if(map.getSource(tempId)) map.removeSource(tempId);
            clearDeleteSelection();
        }

        map.on('mousedown', (e) => {
            if (!isDrawing) return;
            if (currentDrawType === 'polygon') {
                isFreehandDrawing = true;
                currentPoints = [[e.lngLat.lng, e.lngLat.lat]];
                updateTempLayer('line');
            }
        });

        map.on('mousemove', (e) => {
            if (!isDrawing && !isFreehandDrawing) { handleBending(e); return; }
            if (isDrawing && currentDrawType === 'polygon' && isFreehandDrawing) {
                currentPoints.push([e.lngLat.lng, e.lngLat.lat]);
                updateTempLayer('line');
            }
        });

        map.on('mouseup', (e) => {
            if (isDrawing && currentDrawType === 'polygon' && isFreehandDrawing) {
                isFreehandDrawing = false;
                finishFreehandPolygon();
            }
        });

        map.on('zoom', () => {
            const currentZoom = map.getZoom();
            const scaleFactor = Math.max(0.5, Math.pow(1.3, currentZoom - 7.2));
            document.querySelectorAll('.map-feature i, .custom-text-marker').forEach(el => {
                const parent = el.parentElement;
                parent.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
            });
        });

        map.on('click', (e) => {
            if (isFreehandDrawing) return;
            if (!isDrawing) { handleSelectionClick(e); return; }
            if (currentDrawType === 'delete') { handleDeleteSelection(e); return; }
            if (currentDrawType === 'polygon') return;

            const color = document.getElementById('draw-color').value;
            const size = document.getElementById('draw-size').value;
            const label = document.getElementById('draw-label').value;

            if (currentDrawType === 'marker') {
                const id = 'marker-' + Date.now();
                addIconMarker(e.lngLat, selectedIcon, color, size, label, id);
                saveFeature(id, 'marker', {lng: e.lngLat.lng, lat: e.lngLat.lat, icon: selectedIcon}, {color, size}, label, 0);
            }
            else if (currentDrawType === 'text') {
                const text = document.getElementById('text-content').value || "ƒê·ªãa danh";
                const font = document.getElementById('text-font').value;
                const isBold = document.getElementById('text-bold').checked;
                const isItalic = document.getElementById('text-italic').checked;
                const id = 'text-' + Date.now();
                addTextMarker(e.lngLat, text, color, size, font, isBold, isItalic, id);
                saveFeature(id, 'text', {lng: e.lngLat.lng, lat: e.lngLat.lat, text}, {color, size, font, isBold, isItalic}, label, 0);
            }
            else if (currentDrawType === 'arrow') {
                currentPoints.push([e.lngLat.lng, e.lngLat.lat]);
                updateTempLayer('line');
            }
        });

        map.on('dblclick', (e) => {
            if(!isDrawing || currentDrawType === 'delete' || currentDrawType === 'polygon') return;
            e.preventDefault();
            const color = document.getElementById('draw-color').value;
            const size = document.getElementById('draw-size').value;
            const width = document.getElementById('draw-width').value;
            let label = document.getElementById('draw-label').value;

            if (currentDrawType === 'arrow' && currentPoints.length > 1) {
                arrowCounter++;
                if(!label) label = `M≈©i ti·∫øn c√¥ng ${arrowCounter}`;
                const dashed = document.getElementById('draw-dashed').checked;
                const id = 'arrow-' + Date.now();
                addArrowToMap(currentPoints, color, size, width, dashed, id, arrowCounter);
                saveFeature(id, 'arrow', currentPoints, {color, size, width, dashed}, label, arrowCounter);
                selectedLineId = id; 
                stopDrawing();
            }
        });

        function finishFreehandPolygon() {
            if (currentPoints.length < 2) return;
            const color = document.getElementById('draw-color').value;
            let label = document.getElementById('draw-label').value || "V√πng ho·∫°t ƒë·ªông";
            const isDashed = document.getElementById('poly-dashed').checked;
            const isFill = document.getElementById('poly-fill').checked;
            const id = 'poly-' + Date.now();
            
            let coords = currentPoints;
            if (isFill) {
                coords.push(coords[0]);
                coords = [coords];
            }
            
            try {
                const tempLine = turf.lineString(currentPoints);
                const simplified = turf.simplify(tempLine, {tolerance: 0.005, highQuality: false});
                let finalGeoCoords = simplified.geometry.coordinates;
                
                if (isFill) {
                     finalGeoCoords.push(finalGeoCoords[0]);
                     coords = [finalGeoCoords];
                     addPolygonToMap(finalGeoCoords, color, 0.5, id, isDashed);
                } else {
                     coords = finalGeoCoords;
                     map.addSource(id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: coords } } });
                     map.addLayer({
                         id: id + '-outline', type: 'line', source: id, 
                         paint: { 'line-color': color, 'line-width': 3, 'line-dasharray': isDashed ? [2, 2] : [1, 0] }
                     });
                }
                saveFeature(id, 'polygon', coords, {color, opacity: 0.5, isDashed, isFill}, label, 0);
            } catch (e) { console.error(e); }
            stopDrawing();
        }

        function toggleGlowMode() {
            isGlowingEnabled = document.getElementById('chk-glow-effect').checked;
            updateVisibility();
        }

        function updateVisibility() {
            mapData.features.forEach(feat => {
                const step = feat.order;
                const isVisible = (currentTimelineStep === 999) || (step <= currentTimelineStep);
                
                if(feat.type === 'arrow') {
                    if (map.getLayer(feat.id)) map.setLayoutProperty(feat.id, 'visibility', isVisible ? 'visible' : 'none');
                    const head = document.getElementById(feat.id + '-head');
                    if(head) head.style.display = isVisible ? 'block' : 'none';

                    if (head && map.getLayer(feat.id)) {
                        head.classList.remove('feature-dimmed');
                        if (isGlowingEnabled && currentTimelineStep !== 999 && isVisible) {
                            if (step !== currentTimelineStep) {
                                head.classList.add('feature-dimmed');
                                map.setPaintProperty(feat.id, 'line-color', '#555555');
                                map.setPaintProperty(feat.id, 'line-opacity', 0.4);
                            } else {
                                map.setPaintProperty(feat.id, 'line-color', feat.style.color);
                                map.setPaintProperty(feat.id, 'line-opacity', 1);
                            }
                        } else {
                            map.setPaintProperty(feat.id, 'line-color', feat.style.color);
                            map.setPaintProperty(feat.id, 'line-opacity', 1);
                        }
                    }
                }
                else if (feat.type === 'marker') {
                    const el = document.getElementById(feat.id);
                    if(el) {
                         el.classList.remove('feature-dimmed');
                         if(isGlowingEnabled && currentTimelineStep !== 999 && feat.order !== currentTimelineStep && feat.order > 0) {
                             el.classList.add('feature-dimmed');
                         }
                    }
                }
            });
        }

        document.addEventListener('keydown', (e) => {
            if ((e.key === 'x' || e.key === 'X')) {
                if (pendingDeleteId) {
                     if (suppressDeleteWarning) executeDelete(); else document.getElementById('delete-confirm-modal').style.display = 'flex';
                }
            }
            if (e.key === 'u' || e.key === 'U') {
                const chk = document.getElementById('chk-glow-effect'); chk.checked = !chk.checked; toggleGlowMode();
            }
            if (e.key === 'z' || e.key === 'Z') isBending = true;
            if (e.key === 'Escape') {
                if (currentDrawType === 'delete') {
                    document.getElementById('draw-mode').value = 'none'; updateUI(); toggleDrawing(); 
                } else { stopDrawing(); }
                document.getElementById('delete-confirm-modal').style.display = 'none';
                if(selectedRotatable && selectedRotatable.element) selectedRotatable.element.style.outline = 'none';
                selectedRotatable = null;
            }
            if (e.key.toLowerCase() === 't') changeTimeline(1);
            if (e.key.toLowerCase() === 'y') changeTimeline(-1);
            if (selectedRotatable) {
                if (e.key.toLowerCase() === 'a') { selectedRotatable.bearing -= 5; updateRotation(); }
                if (e.key.toLowerCase() === 'd') { selectedRotatable.bearing += 5; updateRotation(); }
            }
        });
        document.addEventListener('keyup', (e) => { if (e.key === 'z' || e.key === 'Z') isBending = false; });

        function updateRotation() {
            if(!selectedRotatable) return;
            const icon = selectedRotatable.element.querySelector('i');
            if(icon) icon.style.transform = `rotate(${selectedRotatable.bearing}deg)`;
        }

        function updateTempLayer(type) {
            const data = { type: 'Feature', geometry: { type: 'LineString', coordinates: currentPoints } };
            if (map.getSource(tempId)) { map.getSource(tempId).setData(data); }
            else {
                map.addSource(tempId, { type: 'geojson', data: data });
                map.addLayer({ id: tempId, type: 'line', source: tempId, paint: { 'line-color': '#c0392b', 'line-width': 3 } });
            }
        }

        function addArrowToMap(coords, color, headSize, lineWidth, dashed, id, order) {
            map.addSource(id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: coords } } });
            map.addLayer({
                id: id, type: 'line', source: id,
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: { 'line-color': color, 'line-width': parseInt(lineWidth), 'line-dasharray': dashed ? [2, 2] : [1, 0] }
            });
            const last = coords[coords.length - 1]; const prev = coords[coords.length - 2];
            let bearing = turf.bearing(turf.point(prev), turf.point(last));
            const iconSize = parseInt(headSize) * 6;
            
            const el = document.createElement('div'); 
            el.className = `map-feature feature-arrow arrow-order-${order}`; 
            el.id = id + '-head';
            el.innerHTML = `<i class="fas fa-long-arrow-alt-up" style="color: ${color}; font-size: ${iconSize}px; display:block; text-shadow:0 0 2px white;"></i>`;
            el.style.cursor = 'pointer'; 
            el.querySelector('i').style.transform = `rotate(${bearing}deg)`;
            
            // FIX: pitchAlignment & rotationAlignment 'map' ensures arrows stick to map ground
            const marker = new maplibregl.Marker({ element: el, rotationAlignment: 'map', pitchAlignment: 'map' }).setLngLat(last).addTo(map);
            
            el.addEventListener('click', (e) => {
                e.stopPropagation();
                if(trySelectForDelete(id, el)) return;
                if(selectedRotatable) selectedRotatable.element.style.outline = 'none';
                selectedRotatable = { marker: marker, element: el, bearing: bearing };
                el.style.borderRadius = "50%"; el.style.outline = "2px dashed #f1c40f";
            });
        }

        // --- UPDATED LEGEND ---
        function createStaticLegend() {
            const container = document.getElementById('static-legend-container');
            const items = [
                { icon: '<i class="fas fa-fire" style="color:#e67e22"></i>', text: 'N∆°i L√™ L·ª£i d·ª±ng c·ªù', type: 'marker', color: '#e67e22', iconName: 'fire' },
                { icon: '<i class="fas fa-mountain" style="color:#5d4037"></i> <i class="fas fa-long-arrow-alt-right" style="color:#c0392b; border-bottom: 2px dashed #c0392b"></i>', text: 'Nghƒ©a qu√¢n r√∫t l√™n n√∫i', type: 'arrow', color: '#c0392b', dashed: true },
                { icon: '<i class="fas fa-long-arrow-alt-right" style="color:#c0392b; transform: rotate(-45deg);"></i>', text: 'H∆∞·ªõng ti·∫øn c·ªßa nghƒ©a qu√¢n', type: 'arrow', color: '#c0392b', dashed: false },
                { icon: '<i class="fas fa-location-arrow" style="color:#c0392b"></i>', text: 'Nghƒ©a qu√¢n ch·∫∑n ƒë√°nh', type: 'marker', color: '#c0392b', iconName: 'location-arrow' },
                { icon: '<i class="fas fa-times" style="color:#c0392b"></i>', text: 'N∆°i ti√™u di·ªát ƒë·ªãch', type: 'marker', color: '#c0392b', iconName: 'times' },
                { icon: '<i class="fas fa-star" style="color:#f1c40f"></i>', text: 'N∆°i ƒë√°nh b·∫°i qu√¢n Minh', type: 'marker', color: '#f1c40f', iconName: 'star' },
                { icon: '<i class="fas fa-chess-rook" style="color:#7f8c8d"></i>', text: 'Th√†nh qu√¢n Minh b·ªã v√¢y', type: 'marker', color: '#7f8c8d', iconName: 'chess-rook' },
                { icon: '<i class="fas fa-long-arrow-alt-right" style="color:#2980b9; border-bottom:2px dashed #2980b9;"></i>', text: 'Qu√¢n Minh r√∫t ch·∫°y', type: 'arrow', color: '#2980b9', dashed: true },
                { icon: '<div style="width:14px;height:14px;background:#eab676;opacity:0.8;border:1px solid #d35400"></div>', text: 'V√πng ho·∫°t ƒë·ªông 1418-1423', type: 'polygon', color: '#eab676', dashed: false },
                { icon: '<div style="width:14px;height:14px;background:#a2d9a2;opacity:0.8;border:1px solid #27ae60"></div>', text: 'V√πng gi·∫£i ph√≥ng 1424-1425', type: 'polygon', color: '#a2d9a2', dashed: false },
                /* NEW ITEM ADDED HERE */
                { icon: '<div style="width:14px;height:14px;background:#c3e6cb;opacity:0.8;border:1px solid #2ecc71"></div>', text: 'V√πng gi·∫£i ph√≥ng 1426-1427', type: 'polygon', color: '#c3e6cb', dashed: false },
                { icon: '<div style="width:20px;height:0px;border-top:2px dashed #000;"></div>', text: 'Bi√™n gi·ªõi qu·ªëc gia', type: 'none', color: '#000' }
            ];
            items.forEach(item => {
                const div = document.createElement('div'); div.className = 'legend-row';
                div.innerHTML = `<div class="l-icon">${item.icon}</div><div class="l-text">${item.text}</div>`;
                if(item.type !== 'none') {
                    div.title = "Click ƒë·ªÉ ch·ªçn v·∫Ω lo·∫°i n√†y";
                    div.onclick = () => {
                        document.getElementById('draw-mode').value = item.type; document.getElementById('draw-color').value = item.color;
                        if(item.type === 'arrow') document.getElementById('draw-dashed').checked = item.dashed;
                        if(item.type === 'marker') selectIcon(item.iconName);
                        updateUI(); if(!isDrawing) toggleDrawing();
                    };
                }
                container.appendChild(div);
            });
        }
        
        function toggleLegend() { const leg = document.getElementById('floating-legend'); const icon = document.getElementById('legend-icon'); leg.classList.toggle('minimized'); icon.className = leg.classList.contains('minimized') ? "fas fa-chevron-up" : "fas fa-chevron-down"; }
        function toggleMapLabels() {
            let labelsVisible = document.getElementById('label-toggle-btn').style.color !== 'rgb(170, 170, 170)';
            labelsVisible = !labelsVisible;
            const btn = document.getElementById('label-toggle-btn');
            btn.innerHTML = labelsVisible ? '<i class="fas fa-font"></i>' : '<i class="fas fa-slash"></i>';
            btn.style.color = labelsVisible ? 'white' : '#aaa';
            const layers = map.getStyle().layers;
            layers.forEach(layer => { if (layer.type === 'symbol') map.setLayoutProperty(layer.id, 'visibility', labelsVisible ? 'visible' : 'none'); });
        }
        function selectIcon(name) { selectedIcon = name; document.querySelectorAll('.icon-option').forEach(el=>el.classList.remove('selected')); event.currentTarget.classList.add('selected'); }
        function updateUI() {
            const mode = document.getElementById('draw-mode').value;
            if (mode === 'delete') { document.getElementById('options-panel').style.display = 'none'; return; }
            document.getElementById('options-panel').style.display = mode === 'none' ? 'none' : 'block';
            document.getElementById('icon-options').style.display = mode === 'marker' ? 'block' : 'none';
            document.getElementById('text-options').style.display = mode === 'text' ? 'block' : 'none';
            document.getElementById('arrow-specific-options').style.display = mode === 'arrow' ? 'block' : 'none';
            document.getElementById('polygon-specific-options').style.display = mode === 'polygon' ? 'block' : 'none';
        }
        
        function trySelectForDelete(id, element) {
             if (currentDrawType === 'delete') {
                clearDeleteSelection(); pendingDeleteId = id; element.classList.add('selected-danger');
                new maplibregl.Popup({closeButton:false, closeOnClick:true, offset: 25}).setLngLat(mapData.features.find(f=>f.id===id).data).setHTML('<div style="color:red; font-weight:bold;">Nh·∫•n X ƒë·ªÉ x√≥a</div>').addTo(map);
                return true;
             } 
             pendingDeleteId = id;
             return false;
        }
        
        function handleDeleteSelection(e) {
             const point = e.point; clearDeleteSelection();
             const arrowLayers = mapData.features.filter(f=>f.type==='arrow').map(f=>f.id);
             const arrowFeatures = map.queryRenderedFeatures(point, { layers: arrowLayers });
             if (arrowFeatures.length > 0) {
                 const id = arrowFeatures[0].layer.id; pendingDeleteId = id;
                 map.setPaintProperty(id, 'line-color', '#ff0000'); 
                 new maplibregl.Popup({closeButton:false}).setLngLat(e.lngLat).setHTML('<div style="color:red; font-weight:bold;">Nh·∫•n X ƒë·ªÉ x√≥a</div>').addTo(map);
                 return;
             }
             const polyLayers = mapData.features.filter(f=>f.type==='polygon').map(f=>f.id + '-fill');
             const polyFeatures = map.queryRenderedFeatures(point, { layers: polyLayers });
             if (polyFeatures.length > 0) {
                 const id = polyFeatures[0].layer.id.replace('-fill', ''); pendingDeleteId = id;
                 map.setPaintProperty(id + '-fill', 'fill-color', '#ff0000'); map.setPaintProperty(id + '-fill', 'fill-opacity', 0.7);
                 new maplibregl.Popup({closeButton:false}).setLngLat(e.lngLat).setHTML('<div style="color:red; font-weight:bold;">Nh·∫•n X ƒë·ªÉ x√≥a</div>').addTo(map);
                 return;
             }
        }
        
        function clearDeleteSelection() {
            if(pendingDeleteId) {
                const feat = mapData.features.find(f => f.id === pendingDeleteId);
                if(feat) {
                    const el = document.getElementById(pendingDeleteId); if(el) el.classList.remove('selected-danger');
                    if(feat.type === 'arrow' && map.getLayer(feat.id)) { map.setPaintProperty(feat.id, 'line-color', feat.style.color); }
                    if(feat.type === 'polygon' && map.getLayer(feat.id+'-fill')) { map.setPaintProperty(feat.id+'-fill', 'fill-color', feat.style.color); map.setPaintProperty(feat.id+'-fill', 'fill-opacity', feat.style.opacity); }
                }
                const popup = document.querySelector('.maplibregl-popup'); if(popup) popup.remove();
            }
        }
        function executeDelete() { if (pendingDeleteId) { deleteFeature(pendingDeleteId); pendingDeleteId = null; } }
        document.getElementById('btn-confirm-delete').addEventListener('click', function() { if (document.getElementById('chk-no-remind').checked) suppressDeleteWarning = true; executeDelete(); document.getElementById('delete-confirm-modal').style.display = 'none'; });
        document.getElementById('btn-cancel-delete').addEventListener('click', function() { document.getElementById('delete-confirm-modal').style.display = 'none'; });
        
        function handleSelectionClick(e) {
             const point = e.point;
             const arrowFeatures = map.queryRenderedFeatures(point, { layers: mapData.features.filter(f=>f.type==='arrow').map(f=>f.id) });
             if (arrowFeatures.length > 0) {
                 selectedLineId = arrowFeatures[0].layer.id; 
                 new maplibregl.Popup().setLngLat(e.lngLat).setHTML('<div class="bend-popup"><b>ƒê√£ ch·ªçn m≈©i t√™n</b><br>Gi·ªØ <b>Z</b> + Di chu·ªôt ƒë·ªÉ u·ªën cong.</div>').addTo(map);
                 return;
             }
        }
        
        function handleBending(e) {
            if (isBending && selectedLineId) {
                const featureObj = mapData.features.find(f => f.id === selectedLineId);
                if (featureObj && featureObj.type === 'arrow') {
                    const originalCoords = featureObj.data; 
                    const start = originalCoords[0]; const end = originalCoords[originalCoords.length - 1]; const mouse = [e.lngLat.lng, e.lngLat.lat];
                    const line = turf.lineString([start, mouse, end]);
                    const curved = turf.bezierSpline(line, { resolution: 10000, sharpness: 0.6 });
                    map.getSource(selectedLineId).setData(curved);
                }
            }
        }
        
        function saveFeature(id, type, data, style, label, order) { mapData.features.push({ id, type, data, style, label, order }); renderTimelineTable(); }
        
        function renderTimelineTable() {
            const tbody = document.getElementById('timeline-list'); tbody.innerHTML = '';
            const arrows = mapData.features.filter(f => f.type === 'arrow').sort((a,b) => a.order - b.order);
            arrows.forEach(feat => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td align="center"><input type="number" class="order-input" value="${feat.order}" onchange="updateFeatureOrder('${feat.id}', this.value)"></td>
                    <td><input type="text" class="name-input" value="${feat.label}" onchange="updateFeatureLabel('${feat.id}', this.value)"></td>
                    <td align="center"><i class="fas fa-trash" style="cursor:pointer; color:#e74c3c;" onclick="confirmDeleteFromTable('${feat.id}')"></i></td>
                `;
                tbody.appendChild(tr);
            });
            updateVisibility();
        }
        window.updateFeatureOrder = function(id, newOrderVal) {
            let newOrder = parseInt(newOrderVal); 
            if(isNaN(newOrder) || newOrder < 0) newOrder = 0;
            const feature = mapData.features.find(f => f.id === id);
            if(feature) { feature.order = newOrder; if(newOrder > arrowCounter) arrowCounter = newOrder; renderTimelineTable(); }
        }
        window.updateFeatureLabel = function(id, newLabel) {
            const feature = mapData.features.find(f => f.id === id);
            if(feature) { feature.label = newLabel; }
        }
        function confirmDeleteFromTable(id) { pendingDeleteId = id; if (suppressDeleteWarning) executeDelete(); else document.getElementById('delete-confirm-modal').style.display = 'flex'; }
        
        function deleteFeature(id) {
            if(map.getLayer(id)) map.removeLayer(id); if(map.getLayer(id+'-fill')) map.removeLayer(id+'-fill'); if(map.getLayer(id+'-outline')) map.removeLayer(id+'-outline'); if(map.getSource(id)) map.removeSource(id);
            const el = document.getElementById(id); if(el) el.remove(); const headEl = document.getElementById(id+'-head'); if(headEl) headEl.remove();
            mapData.features = mapData.features.filter(f => f.id !== id); renderTimelineTable();
        }
        
        function changeTimeline(val) {
            if (currentTimelineStep === 999 && val === 1) currentTimelineStep = 0; 
            currentTimelineStep += val;
            if (currentTimelineStep < 0) currentTimelineStep = 0; 
            if (currentTimelineStep > arrowCounter + 5) currentTimelineStep = 999;
            document.getElementById('current-step-display').innerText = currentTimelineStep === 999 ? "Hi·ªán t·∫•t c·∫£" : `B∆∞·ªõc: ${currentTimelineStep}`;
            updateVisibility();
        }
        function showAllTimeline() { currentTimelineStep = 999; document.getElementById('current-step-display').innerText = "Hi·ªán t·∫•t c·∫£"; updateVisibility(); }
        
        function addPolygonToMap(coords, color, opacity, id, isDashed) {
            map.addSource(id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'Polygon', coordinates: [coords] } } });
            map.addLayer({ id: id + '-fill', type: 'fill', source: id, paint: { 'fill-color': color, 'fill-opacity': opacity } });
            map.addLayer({ id: id + '-outline', type: 'line', source: id, paint: { 'line-color': color, 'line-width': 2, 'line-dasharray': isDashed ? [2, 2] : [1, 0] } });
        }
        
        function addIconMarker(lngLat, icon, color, size, label, id) {
            const el = document.createElement('div'); el.className = `map-feature`; el.id = id;
            const px = parseInt(size) * 8; el.innerHTML = `<i class="fas fa-${icon}" style="color:${color}; font-size:${px}px; text-shadow: 1px 1px 1px black;"></i>`;
            const marker = new maplibregl.Marker({ element: el }).setLngLat(lngLat).addTo(map);
            el.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                if(trySelectForDelete(id, el)) return;
                if(selectedRotatable) selectedRotatable.element.style.outline = 'none';
                selectedRotatable = { marker: marker, element: el, bearing: 0 };
                el.style.borderRadius = "20%"; el.style.outline = "2px dashed #f1c40f";
            });
        }
        
        function addTextMarker(lngLat, text, color, size, font, bold, italic, id) {
            const el = document.createElement('div'); el.className = `custom-text-marker`; el.id = id;
            el.style.color = color; el.style.fontSize = (parseInt(size) * 5) + 'px'; el.style.fontFamily = font; el.style.fontWeight = bold ? 'bold' : 'normal'; el.style.fontStyle = italic ? 'italic' : 'normal'; el.innerText = text; el.style.cursor = 'pointer';
            el.addEventListener('click', (e) => { e.stopPropagation(); trySelectForDelete(id, el); });
            new maplibregl.Marker({ element: el }).setLngLat(lngLat).addTo(map);
        }
        
        function exportJSON() { const blob = new Blob([JSON.stringify(mapData)], {type: "application/json"}); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = "tactical_map_v10.json"; link.click(); }
        function importJSON(input) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    mapData.features.forEach(f => deleteFeature(f.id));
                    mapData = { features: [] }; arrowCounter = 0;
                    data.features.forEach(f => {
                        if (f.order > arrowCounter) arrowCounter = f.order;
                        if (f.type === 'arrow') {
                            addArrowToMap(f.data, f.style.color, f.style.size, f.style.width || 4, f.style.dashed, f.id, f.order);
                            saveFeature(f.id, 'arrow', f.data, f.style, f.label, f.order);
                        } else if (f.type === 'marker') {
                            addIconMarker({lng: f.data.lng, lat: f.data.lat}, f.data.icon, f.style.color, f.style.size, f.label, f.id);
                            saveFeature(f.id, 'marker', f.data, f.style, f.label, 0);
                        } else if (f.type === 'text') {
                            addTextMarker({lng: f.data.lng, lat: f.data.lat}, f.data.text, f.style.color, f.style.size, f.style.font, f.style.isBold, f.style.isItalic, f.id);
                            saveFeature(f.id, 'text', f.data, f.style, f.label, 0);
                        } else if (f.type === 'polygon') {
                            if (f.style.isFill) {
                                addPolygonToMap(f.data, f.style.color, f.style.opacity, f.id, f.style.isDashed);
                            } else {
                                map.addSource(f.id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: f.data } } });
                                map.addLayer({ id: f.id + '-outline', type: 'line', source: f.id, paint: { 'line-color': f.style.color, 'line-width': 3, 'line-dasharray': f.style.isDashed ? [2, 2] : [1, 0] } });
                            }
                            saveFeature(f.id, 'polygon', f.data, f.style, f.label, 0);
                        }
                    });
                    alert("ƒê√£ t·∫£i b·∫£n ƒë·ªì th√†nh c√¥ng!");
                } catch (err) { console.error(err); alert("L·ªói file kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng."); }
            };
            reader.readAsText(file); input.value = '';
        }
    </script>
</body>
</html>
