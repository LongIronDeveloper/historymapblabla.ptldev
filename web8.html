<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B·∫£n ƒê·ªì Chi·∫øn Thu·∫≠t - Tactical Editor v21 (Audio & Timeline)</title>
    
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Merriweather:ital,wght@0,400;0,700;1,400&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'Roboto', sans-serif; background-color: #e0d5b0; }
        
        #map { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 360px; height: 100vh;
            color: #dcdcdc; padding: 15px; box-sizing: border-box;
            transition: transform 0.3s ease;
            position: absolute; z-index: 1000; left: 0; top: 0; background: #2b2b2b;
            overflow-y: auto; box-shadow: 4px 0 15px rgba(0,0,0,0.6);
            border-right: 3px solid #8b4513;
            display: flex; flex-direction: column; gap: 12px;
        }
        #sidebar.collapsed { transform: translateX(-370px); }

        h2 { margin: 0; font-family: 'Cinzel', serif; font-size: 22px; text-align: center; color: #f39c12; border-bottom: 2px solid #8b4513; padding-bottom: 10px; text-shadow: 1px 1px 2px black; letter-spacing: 1px; }
        h3 { margin: 0; border-bottom: 1px solid #555; padding-bottom: 5px; font-size: 14px; color: #f1c40f; text-transform: uppercase; letter-spacing: 1px; }

        .control-group { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; border: 1px solid #444; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 13px; color: #aaa; }
        
        input, select, button { width: 100%; margin-bottom: 8px; padding: 8px; border-radius: 4px; border: 1px solid #555; background: #3c3c3c; color: white; font-size: 13px; }
        input[type="checkbox"] { width: auto; margin-right: 5px; vertical-align: middle; }
        input[type="range"] { width: 100%; margin: 5px 0; cursor: pointer; }
        
        button.btn-action { background: #5d4037; font-weight: bold; border: 1px solid #8d6e63; cursor: pointer; color: #f1c40f; }
        button.btn-action:hover { background: #795548; }

        /* Icon Grid Fix */
        .icon-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .icon-option { background: #4a3b32; border: 1px solid #6d4c41; padding: 8px; text-align: center; cursor: pointer; border-radius: 4px; }
        .icon-option.selected { background: #f1c40f; color: #2c3e50; border-color: #fff; box-shadow: 0 0 8px #f1c40f; }
        
        .help-box { font-size: 12px; color: #bdc3c7; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; line-height: 1.5; border-left: 3px solid #e74c3c; }
        .help-key { display: inline-block; background: #eee; color: #333; padding: 0 4px; border-radius: 2px; font-weight: bold; font-family: monospace; font-size: 10px; }

        .top-right-controls {
            position: absolute; top: 15px; right: 15px; display: flex; flex-direction: column; gap: 5px; 
            z-index: 9999; pointer-events: auto;
        }

        #toggle-btn, #label-toggle-btn {
            width: 36px; height: 36px; 
            background: #8b4513; color: white; border: 2px solid #d35400; cursor: pointer; border-radius: 4px;
            display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            position: relative; top: auto; right: auto;
        }
        #label-toggle-btn { background: #2c3e50; border-color: #34495e; }

        .timeline-table { width: 100%; font-size: 12px; border-collapse: collapse; }
        .timeline-table td { padding: 4px; border-bottom: 1px solid #444; vertical-align: middle; }
        .order-input { width: 40px; text-align: center; background: #222; border: 1px solid #555; color: #f1c40f; font-weight: bold; padding: 2px; margin: 0; }
        .name-input { width: 100%; background: transparent; border: none; color: #dcdcdc; font-family: inherit; }
        .name-input:focus { border-bottom: 1px solid #f1c40f; outline: none; }

        #floating-legend {
            position: absolute; bottom: 20px; right: 20px;
            width: 350px; max-height: 60vh;
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid #8b4513; border-radius: 5px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); z-index: 2000;
            overflow: hidden; 
            color: #333; font-family: 'Merriweather', serif;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            transform-origin: bottom right;
        }
        #floating-legend.minimized { transform: translateY(calc(100% - 36px)); }
        
        .legend-header {
            background: #8b4513; color: #f1c40f; padding: 10px; font-weight: bold;
            display: flex; justify-content: space-between; align-items: center; cursor: pointer;
            font-size: 13px; text-transform: uppercase; user-select: none;
        }
        .legend-body { padding: 5px; overflow-y: auto; max-height: calc(60vh - 40px); }
        .legend-row { display: flex; align-items: center; gap: 10px; padding: 6px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s; }
        .legend-row:hover { background: #f0e6d2; }
        .l-icon { width: 30px; text-align: center; display: flex; justify-content: center; align-items: center; }
        .l-text { flex: 1; font-size: 11px; line-height: 1.3; font-weight: bold; color: #555; }
        
        .map-feature i { filter: sepia(0.4) drop-shadow(0px 2px 2px rgba(0,0,0,0.8)); }
        .bend-popup { font-size: 11px; color: #333; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; 
            z-index: 20000;
        }
        .modal-content {
            background: white; padding: 20px; border-radius: 8px; width: 320px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); font-family: Arial, sans-serif;
            pointer-events: auto;
        }
        .modal-content h3 { color: #d9534f; margin-top: 0; border-bottom: none; font-size: 18px; text-align: left; }
        .modal-buttons { margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px; }
        .btn-danger { background: #d9534f; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; width: auto; }
        .btn-secondary { background: #ccc; color: black; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; width: auto; }
        
        .selected-edit { outline: 3px dashed #00b894 !important; box-shadow: 0 0 15px #00b894; }
        .selected-danger { outline: 3px dashed red !important; border-radius: 4px; box-shadow: 0 0 10px red; background: rgba(255, 0, 0, 0.2); }

        .feature-dimmed i { filter: grayscale(100%) brightness(0.3) opacity(0.4) !important; transition: filter 0.3s ease; }

        .map-feature {
            position: absolute; top: 0; left: 0;
            display: flex; justify-content: center; align-items: center;
            transform: translate(-50%, -50%); 
            pointer-events: auto;
        }

        .custom-text-marker { 
            position: absolute; top: 0; left: 0;
            text-shadow: 1px 1px 0 #000; 
            white-space: nowrap; 
            transform: translate(-50%, -50%); 
            pointer-events: auto; background: transparent;
        }
    </style>
</head>
<body>

    <div class="top-right-controls">
        <button id="toggle-btn" title="ƒê√≥ng/M·ªü B·∫£ng C√¥ng C·ª•"><i class="fas fa-bars"></i></button>
        <button id="label-toggle-btn" title="·∫®n/Hi·ªán T√™n ƒê·ªãa Danh"><i class="fas fa-font"></i></button>
    </div>

    <div id="sidebar">
        <h2>B·∫¢NG C√îNG C·ª§ V·∫º</h2>
        <div class="control-group">
            <h3><i class="fas fa-info-circle"></i> H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng</h3>
            <div class="help-box">
                <b>1. DI CHUY·ªÇN:</b> Ch·ªçn ƒë·ªëi t∆∞·ª£ng -> D√πng ph√≠m <span class="help-key">‚Üë</span> <span class="help-key">‚Üì</span> <span class="help-key">‚Üê</span> <span class="help-key">‚Üí</span> (2px).<br>
                <b>2. CH·ªàNH S·ª¨A:</b> Click ch·ªçn ƒë·ªÉ ƒë·ªïi m√†u/size. S·ª≠a n·ªôi dung ch·ªØ ·ªü √¥ b√™n d∆∞·ªõi.<br>
                <b>3. XOAY:</b> Ch·ªçn icon/m≈©i t√™n -> D√πng ph√≠m <span class="help-key">A</span> (Tr√°i) / <span class="help-key">D</span> (Ph·∫£i).<br>
                <b>4. TIMELINE:</b> M≈©i t√™n & Icon ƒë·ªÅu c√≥ th·ªÉ g√°n STT ƒë·ªÉ xu·∫•t hi·ªán theo k·ªãch b·∫£n.<br>
                <b>5. B·∫∫ CONG:</b> Gi·ªØ <span class="help-key">Z</span> + Di chu·ªôt (khi kh√¥ng v·∫Ω).<br>
                <b>6. X√ìA:</b> Ch·ªçn ch·∫ø ƒë·ªô X√≥a -> Click ƒë·ªëi t∆∞·ª£ng.
            </div>
        </div>

        <div class="control-group">
            <h3>C√¥ng C·ª• Chi·∫øn Thu·∫≠t</h3>
            <select id="draw-mode" onchange="updateUI()">
                <option value="none">-- Ch·ªçn Ch·∫ø ƒê·ªô --</option>
                <option value="arrow">M≈©i T√™n (Chi·∫øn d·ªãch)</option>
                <option value="marker">Bi·ªÉu T∆∞·ª£ng (Icon)</option>
                <option value="text">VƒÉn B·∫£n (Ghi ch√∫)</option>
                <option value="polygon">V√πng / N√©t v·∫Ω t·ª± do</option>
                <option value="delete" style="color: #e74c3c; font-weight: bold;">üóëÔ∏è Ch·∫ø ƒë·ªô X√≥a (Ph√≠m X)</option>
            </select>
            <button class="btn-action" id="action-btn" onclick="toggleDrawing()">B·∫Øt ƒë·∫ßu v·∫Ω</button>
        </div>

        <div id="options-panel">
            <div class="control-group">
                <label>Thu·ªôc t√≠nh (ƒê·ªëi t∆∞·ª£ng ƒëang ch·ªçn):</label>
                
                <div id="edit-text-container" style="display:none; margin-bottom: 8px;">
                    <label style="color:#00b894;">S·ª≠a n·ªôi dung ch·ªØ:</label>
                    <input type="text" id="edit-text-content" class="safe-input" style="width:100%; border: 1px solid #00b894;" oninput="updateSelectedTextContent()">
                </div>

                <div style="display:flex; gap:5px; align-items:center; flex-wrap: wrap;">
                    <input type="color" id="draw-color" value="#c0392b" style="width:40px; height:30px; padding:0;" oninput="updateSelectedFeatureStyle()">
                    <input type="number" id="draw-size" class="safe-input" value="4" min="1" max="50" title="K√≠ch th∆∞·ªõc" style="width:50px;" placeholder="Size" oninput="updateSelectedFeatureStyle()">
                    <input type="number" id="draw-width" class="safe-input" value="4" min="1" max="20" title="ƒê·ªô d√†y (M≈©i t√™n)" style="width:50px;" placeholder="D√†y" oninput="updateSelectedFeatureStyle()">
                </div>
                <div id="arrow-specific-options" style="display:none; margin-top:5px;">
                     <label><input type="checkbox" id="draw-dashed"> N√©t ƒë·ª©t (R√∫t lui/B√≠ m·∫≠t)</label>
                </div>
                <div id="polygon-specific-options" style="display:none; margin-top:5px;">
                    <label><input type="checkbox" id="poly-fill" checked> T·ª± ƒë·ªông ƒë·ªï m√†u (Kh√©p k√≠n)</label>
                    <label><input type="checkbox" id="poly-dashed"> Vi·ªÅn n√©t ƒë·ª©t</label>
                </div>
                <input type="text" id="draw-label" class="safe-input" placeholder="T√™n (Hi·ªÉn th·ªã trong timeline)..." style="margin-top:5px;">
            </div>

            <div class="control-group" id="icon-options" style="display:none;">
                <label>Bi·ªÉu t∆∞·ª£ng:</label>
                <div class="icon-grid">
                    <div class="icon-option selected" onclick="selectIcon('fire')" title="N∆°i kh·ªüi nghƒ©a"><i class="fas fa-fire" style="color:#e67e22"></i></div>
                    <div class="icon-option" onclick="selectIcon('flag')" title="S·ªü ch·ªâ huy"><i class="fas fa-flag" style="color:#c0392b"></i></div>
                    <div class="icon-option" onclick="selectIcon('star')" title="Chi·∫øn th·∫Øng"><i class="fas fa-star" style="color:#f1c40f"></i></div>
                    <div class="icon-option" onclick="selectIcon('chess-rook')" title="Th√†nh tr√¨"><i class="fas fa-chess-rook" style="color:#7f8c8d"></i></div>
                    <div class="icon-option" onclick="selectIcon('skull')" title="Ti√™u di·ªát"><i class="fas fa-skull" style="color:#fff"></i></div>
                    <div class="icon-option" onclick="selectIcon('campground')" title="Doanh tr·∫°i"><i class="fas fa-campground" style="color:#27ae60"></i></div>
                    <div class="icon-option" onclick="selectIcon('mountain')" title="N√∫i/ƒê·ªãa h√¨nh"><i class="fas fa-mountain" style="color:#5d4037"></i></div>
                    <div class="icon-option" onclick="selectIcon('location-arrow')" title="Ch·∫∑n ƒë√°nh"><i class="fas fa-location-arrow" style="color:#c0392b"></i></div>
                    <div class="icon-option" onclick="selectIcon('times')" title="D·∫•u X (Di·ªát)"><i class="fas fa-times" style="color:#c0392b"></i></div>
                </div>
            </div>

            <div class="control-group" id="text-options" style="display:none;">
                <input type="text" id="text-content" class="safe-input" placeholder="N·ªôi dung ch·ªØ m·ªõi...">
                <select id="text-font">
                    <option value="'Merriweather', serif">Merriweather (C·ªï ƒëi·ªÉn)</option>
                    <option value="'Roboto', sans-serif">Roboto (Hi·ªán ƒë·∫°i)</option>
                </select>
                <div style="display:flex; gap:10px;">
                    <label><input type="checkbox" id="text-bold" checked> ƒê·∫≠m</label>
                    <label><input type="checkbox" id="text-italic"> Nghi√™ng</label>
                </div>
            </div>
        </div>

        <div class="control-group">
            <h3>Di·ªÖn Bi·∫øn (Timeline)</h3>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                <span id="current-step-display" style="font-size:13px; font-weight:bold; color:#f1c40f;">Hi·ªán t·∫•t c·∫£</span>
                <div style="display:flex; gap: 2px;">
                    <button onclick="changeTimeline(-1)" style="width:30px; margin:0;" title="L√πi (Y)">Y</button>
                    <button onclick="changeTimeline(1)" style="width:30px; margin:0;" title="Ti·∫øn (T)">T</button>
                    <button onclick="showAllTimeline()" style="width:30px; margin:0; background:#f39c12; color:#000;" title="Hi·ªán t·∫•t c·∫£ (M·∫Øt)"><i class="fas fa-eye"></i></button>
                </div>
            </div>
            <label style="font-size:11px; color:#aaa; display:block;">
                <input type="checkbox" id="chk-glow-effect" onchange="toggleGlowMode()"> Hi·ªáu ·ª©ng "L√†m t·ªëi" (Ph√≠m U)
            </label>
            <label style="font-size:11px; color:#aaa; display:block;">
                <input type="checkbox" id="chk-sound-effect"> B·∫≠t √¢m thanh h√†nh qu√¢n (5s)
            </label>
            <div style="max-height: 180px; overflow-y: auto; background: rgba(0,0,0,0.2); margin-top:5px;">
                <table class="timeline-table">
                    <thead>
                        <tr style="color:#aaa; border-bottom:1px solid #555;">
                            <th align="center" width="40">STT</th>
                            <th align="left">ƒê·ªëi T∆∞·ª£ng</th>
                            <th width="30">X√≥a</th>
                        </tr>
                    </thead>
                    <tbody id="timeline-list"></tbody>
                </table>
            </div>
        </div>
        
        <div class="control-group" style="margin-top:auto; border-top: 2px solid #8b4513;">
             <h3><i class="fas fa-music"></i> Nh·∫°c N·ªÅn (BGM)</h3>
             <label style="display:flex; justify-content:space-between;">
                 <span>B·∫≠t/T·∫Øt:</span>
                 <input type="checkbox" id="bgm-toggle" onchange="toggleBGM()">
             </label>
             <label>√Çm l∆∞·ª£ng: <span id="bgm-vol-display">15%</span></label>
             <input type="range" id="bgm-volume" min="0" max="100" value="15" oninput="setBGMVolume(this.value)">
             <div id="youtube-player" style="display:none;"></div>
        </div>

        <div class="control-group">
             <button class="btn-action" onclick="exportJSON()">L∆∞u B·∫£n ƒê·ªì (JSON)</button>
             <input type="file" id="file-input" style="display: none;" onchange="importJSON(this)">
             <button class="btn-action" style="background:#333; margin-top:5px;" onclick="document.getElementById('file-input').click()">M·ªü B·∫£n ƒê·ªì</button>
        </div>
    </div>

    <div id="floating-legend">
        <div class="legend-header" onclick="toggleLegend()">
            <span><i class="fas fa-map"></i> Ch√∫ Gi·∫£i Qu√¢n S·ª±</span>
            <i class="fas fa-chevron-down" id="legend-icon"></i>
        </div>
        <div class="legend-body" id="static-legend-container"></div>
    </div>

    <div id="map"></div>

    <div id="delete-confirm-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3>‚ö†Ô∏è X√°c nh·∫≠n x√≥a</h3>
            <p>B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ƒë·ªëi t∆∞·ª£ng ƒëang ch·ªçn kh√¥ng?</p>
            <label style="display:block; margin: 10px 0; font-size: 13px; color:#555;">
                <input type="checkbox" id="chk-no-remind"> Kh√¥ng nh·∫Øc l·∫°i
            </label>
            <div class="modal-buttons">
                <button id="btn-confirm-delete" type="button" class="btn-danger">X√≥a (X)</button>
                <button id="btn-cancel-delete" type="button" class="btn-secondary">H·ªßy (Esc)</button>
            </div>
        </div>
    </div>

    <script src="https://www.youtube.com/iframe_api"></script>

    <script>
        // --- 1. CONFIG & INIT ---
        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://demotiles.maplibre.org/style.json', 
            center: [105.4, 19.3], 
            zoom: 7.2, pitch: 0, antialias: true
        });

        let mapData = { features: [] };
        let markers = {}; 

        let isDrawing = false;
        let isFreehandDrawing = false;
        let currentDrawType = 'none';
        let currentPoints = [];
        let tempId = 'temp-layer';
        
        let selectedIcon = 'fire';
        let selectedFeatureId = null; 
        let isBending = false;

        let currentTimelineStep = 999;
        let arrowCounter = 0;
        let pendingDeleteId = null;
        let suppressDeleteWarning = false; 
        
        let isGlowingEnabled = false;
        
        // Audio Vars
        let marchingAudio = new Audio('marching-loop-32908.mp3');
        let marchingTimeout;
        let player; // YouTube Player

        map.on('load', () => {
            map.addSource('vietnam-border', { type: 'geojson', data: 'https://raw.githubusercontent.com/vietnam-geospatial/vietnam-administrative-boundaries/master/vietnam_boundary.geojson' });
            map.addLayer({ id: 'vn-border-halo', type: 'line', source: 'vietnam-border', paint: { 'line-color': '#f1c40f', 'line-width': 6, 'line-opacity': 0.4 } });
            map.addLayer({ id: 'vn-border-line', type: 'line', source: 'vietnam-border', paint: { 'line-color': '#8b4513', 'line-width': 2 } });
            map.addLayer({ id: 'layer-separator', type: 'background', layout: { 'visibility': 'visible' }, paint: { 'background-color': 'rgba(0,0,0,0)' } });
            
            createStaticLegend();
            
            document.getElementById('toggle-btn').addEventListener('click', function() { document.getElementById('sidebar').classList.toggle('collapsed'); });
            document.getElementById('label-toggle-btn').addEventListener('click', function() { toggleMapLabels(); });

            document.getElementById('btn-confirm-delete').addEventListener('click', function(e) {
                e.stopPropagation();
                if (document.getElementById('chk-no-remind').checked) suppressDeleteWarning = true;
                executeDelete();
                document.getElementById('delete-confirm-modal').style.display = 'none';
            });

            document.getElementById('btn-cancel-delete').addEventListener('click', function(e) {
                e.stopPropagation();
                document.getElementById('delete-confirm-modal').style.display = 'none';
            });
        });

        // --- YOUTUBE BGM ---
        function onYouTubeIframeAPIReady() {
            player = new YT.Player('youtube-player', {
                height: '0', width: '0',
                videoId: 'HqKsP3Ed1nk',
                playerVars: { 'playsinline': 1, 'controls': 0, 'loop': 1, 'playlist': 'HqKsP3Ed1nk' },
                events: { 'onReady': onPlayerReady }
            });
        }
        function onPlayerReady(event) {
            event.target.setVolume(15);
        }
        function toggleBGM() {
            if(!player) return;
            const checkbox = document.getElementById('bgm-toggle');
            if(checkbox.checked) player.playVideo(); else player.pauseVideo();
        }
        function setBGMVolume(val) {
            document.getElementById('bgm-vol-display').innerText = val + '%';
            if(player) player.setVolume(val);
        }

        // --- MARCHING SOUND ---
        function playMarchingSound() {
            if(!document.getElementById('chk-sound-effect').checked) return;
            marchingAudio.currentTime = 0;
            marchingAudio.play().catch(e => console.log("Audio play blocked"));
            if(marchingTimeout) clearTimeout(marchingTimeout);
            marchingTimeout = setTimeout(() => {
                marchingAudio.pause();
                marchingAudio.currentTime = 0;
            }, 5000);
        }

        // --- INTERACTION ---
        function toggleDrawing() {
            isDrawing = !isDrawing;
            const btn = document.getElementById('action-btn');
            currentDrawType = document.getElementById('draw-mode').value;
            
            if(currentDrawType === 'delete') {
                isDrawing = true; 
                btn.innerText = "THO√ÅT CH·∫æ ƒê·ªò X√ìA (ESC)"; btn.style.background = "#d35400"; btn.style.color = "white";
                map.getCanvas().style.cursor = 'not-allowed'; 
                selectFeature(null);
            }
            else if(isDrawing) {
                btn.innerText = "D·ª™NG V·∫º (ESC)"; 
                map.getCanvas().style.cursor = 'crosshair';
                map.dragPan.enable();
                if (currentDrawType === 'polygon') map.dragPan.disable();
                btn.style.background = "#c0392b"; btn.style.color = "white";
                selectFeature(null);
            } else {
                stopDrawing();
            }
        }

        function stopDrawing() {
            isDrawing = false; isFreehandDrawing = false; currentPoints = [];
            const btn = document.getElementById('action-btn');
            btn.innerText = "B·∫Øt ƒë·∫ßu v·∫Ω"; btn.style.background = "#5d4037"; btn.style.color = "#f1c40f";
            map.getCanvas().style.cursor = '';
            map.dragPan.enable();
            if(map.getLayer(tempId)) map.removeLayer(tempId);
            if(map.getSource(tempId)) map.removeSource(tempId);
        }

        map.on('mousedown', (e) => {
            if (!isDrawing) return;
            if (currentDrawType === 'polygon') {
                isFreehandDrawing = true;
                currentPoints = [[e.lngLat.lng, e.lngLat.lat]];
                updateTempLayer('line');
            }
        });

        map.on('mousemove', (e) => {
            if (!isDrawing && !isFreehandDrawing) { handleBending(e); return; }
            if (isDrawing && currentDrawType === 'polygon' && isFreehandDrawing) {
                currentPoints.push([e.lngLat.lng, e.lngLat.lat]);
                updateTempLayer('line');
            }
        });

        map.on('mouseup', (e) => {
            if (isDrawing && currentDrawType === 'polygon' && isFreehandDrawing) {
                isFreehandDrawing = false;
                finishFreehandPolygon();
            }
        });

        function updateMarkerScales() {
            const currentZoom = map.getZoom();
            const scaleFactor = Math.max(0.5, Math.pow(1.3, currentZoom - 7.2));
            document.querySelectorAll('.map-feature, .custom-text-marker').forEach(el => {
                el.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
            });
        }
        map.on('zoom', updateMarkerScales);

        function selectFeature(id) {
            if (selectedFeatureId) {
                const oldEl = document.getElementById(selectedFeatureId);
                if (oldEl) oldEl.classList.remove('selected-edit');
                const head = document.getElementById(selectedFeatureId + '-head');
                if(head) head.classList.remove('selected-edit');
            }
            selectedFeatureId = id;
            const container = document.getElementById('edit-text-container');
            container.style.display = 'none'; 
            if (id) {
                const feature = mapData.features.find(f => f.id === id);
                if (feature) {
                    document.getElementById('draw-color').value = feature.style.color || '#000000';
                    document.getElementById('draw-size').value = feature.style.size || 4;
                    document.getElementById('draw-width').value = feature.style.width || 4;
                    const el = document.getElementById(id);
                    if(el) el.classList.add('selected-edit');
                    const head = document.getElementById(id + '-head');
                    if(head) head.classList.add('selected-edit');
                    if (feature.type === 'text') {
                        container.style.display = 'block';
                        document.getElementById('edit-text-content').value = feature.data.text;
                    }
                }
            }
        }

        window.updateSelectedTextContent = function() {
            if (!selectedFeatureId) return;
            const feature = mapData.features.find(f => f.id === selectedFeatureId);
            if (feature && feature.type === 'text') {
                const newText = document.getElementById('edit-text-content').value;
                feature.data.text = newText;
                const el = document.getElementById(feature.id);
                if (el) el.innerText = newText;
            }
        }

        window.updateSelectedFeatureStyle = function() {
            if (!selectedFeatureId) return;
            const feature = mapData.features.find(f => f.id === selectedFeatureId);
            if (!feature) return;
            const color = document.getElementById('draw-color').value;
            const size = document.getElementById('draw-size').value;
            const width = document.getElementById('draw-width').value;
            feature.style.color = color;
            feature.style.size = size;
            feature.style.width = width;
            if (feature.type === 'arrow') {
                if(map.getLayer(feature.id)) {
                    map.setPaintProperty(feature.id, 'line-color', color);
                    map.setPaintProperty(feature.id, 'line-width', parseInt(width));
                }
                const head = document.getElementById(feature.id + '-head');
                if (head) {
                    const iconSize = parseInt(size) * 6;
                    head.innerHTML = `<i class="fas fa-long-arrow-alt-up" style="color: ${color}; font-size: ${iconSize}px; display:block; text-shadow:0 0 2px white;"></i>`;
                }
            } else if (feature.type === 'marker') {
                const el = document.getElementById(feature.id);
                if (el) {
                    const px = parseInt(size) * 8;
                    el.innerHTML = `<i class="fas fa-${feature.data.icon}" style="color:${color}; font-size:${px}px; text-shadow: 1px 1px 1px black;"></i>`;
                }
            } else if (feature.type === 'text') {
                const el = document.getElementById(feature.id);
                if (el) {
                    el.style.color = color;
                    el.style.fontSize = (parseInt(size) * 5) + 'px';
                }
            } else if (feature.type === 'polygon') {
                if(map.getLayer(feature.id + '-fill')) { map.setPaintProperty(feature.id + '-fill', 'fill-color', color); }
                if(map.getLayer(feature.id + '-outline')) { map.setPaintProperty(feature.id + '-outline', 'line-color', color); }
            }
        }

        function moveSelectedFeature(dx, dy) {
            if (!selectedFeatureId) return;
            const feature = mapData.features.find(f => f.id === selectedFeatureId);
            if (!feature) return;
            const zoom = map.getZoom();
            const factor = 0.0001 * Math.pow(2, 20 - zoom); 
            const shiftLng = dx * factor;
            const shiftLat = dy * factor;
            if (feature.type === 'arrow' || feature.type === 'polygon') {
                const moveCoord = (coord) => [coord[0] + shiftLng, coord[1] + shiftLat];
                let newCoords;
                if (feature.type === 'arrow') {
                    newCoords = feature.data.map(moveCoord);
                    feature.data = newCoords; 
                    map.getSource(feature.id).setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: newCoords } });
                    const last = newCoords[newCoords.length - 1];
                    if (markers[feature.id]) markers[feature.id].setLngLat(last);
                } else if (feature.type === 'polygon') {
                    newCoords = feature.data.map(ring => ring.map(moveCoord));
                    feature.data = newCoords;
                    map.getSource(feature.id).setData({ type: 'Feature', geometry: { type: 'Polygon', coordinates: newCoords } });
                }
            } else if (feature.type === 'marker' || feature.type === 'text') {
                feature.data.lng += shiftLng;
                feature.data.lat += shiftLat;
                if (markers[feature.id]) { markers[feature.id].setLngLat([feature.data.lng, feature.data.lat]); }
            }
        }

        map.on('click', (e) => {
            if (isFreehandDrawing) return;
            if (!isDrawing && currentDrawType !== 'delete') {
                const point = e.point;
                const arrowFeatures = map.queryRenderedFeatures(point, { layers: mapData.features.filter(f=>f.type==='arrow').map(f=>f.id) });
                if (arrowFeatures.length > 0) { selectFeature(arrowFeatures[0].layer.id); return; }
                const polyLayers = mapData.features.filter(f=>f.type==='polygon').map(f=>f.id + '-fill');
                const polyFeatures = map.queryRenderedFeatures(point, { layers: polyLayers });
                if (polyFeatures.length > 0) { selectFeature(polyFeatures[0].layer.id.replace('-fill', '')); return; }
                selectFeature(null);
                return;
            }
            if (currentDrawType === 'delete') { handleDeleteSelection(e); return; }
            if (currentDrawType === 'polygon') return;
            const color = document.getElementById('draw-color').value;
            const size = document.getElementById('draw-size').value;
            const label = document.getElementById('draw-label').value;
            if (currentDrawType === 'marker') {
                const id = 'marker-' + Date.now();
                const m = addIconMarker(e.lngLat, selectedIcon, color, size, label, id);
                saveFeature(id, 'marker', {lng: e.lngLat.lng, lat: e.lngLat.lat, icon: selectedIcon}, {color, size}, label, 0);
                updateMarkerScales();
            } else if (currentDrawType === 'text') {
                const text = document.getElementById('text-content').value || "ƒê·ªãa danh";
                const font = document.getElementById('text-font').value;
                const isBold = document.getElementById('text-bold').checked;
                const isItalic = document.getElementById('text-italic').checked;
                const id = 'text-' + Date.now();
                const m = addTextMarker(e.lngLat, text, color, size, font, isBold, isItalic, id);
                saveFeature(id, 'text', {lng: e.lngLat.lng, lat: e.lngLat.lat, text}, {color, size, font, isBold, isItalic}, label, 0);
                updateMarkerScales();
            } else if (currentDrawType === 'arrow') {
                currentPoints.push([e.lngLat.lng, e.lngLat.lat]);
                updateTempLayer('line');
            }
        });

        map.on('dblclick', (e) => {
            if(!isDrawing || currentDrawType === 'delete' || currentDrawType === 'polygon') return;
            e.preventDefault();
            const color = document.getElementById('draw-color').value;
            const size = document.getElementById('draw-size').value;
            const width = document.getElementById('draw-width').value;
            let label = document.getElementById('draw-label').value;
            if (currentDrawType === 'arrow' && currentPoints.length > 1) {
                arrowCounter++;
                if(!label) label = `M≈©i ti·∫øn c√¥ng ${arrowCounter}`;
                const dashed = document.getElementById('draw-dashed').checked;
                const id = 'arrow-' + Date.now();
                const m = addArrowToMap(currentPoints, color, size, width, dashed, id, arrowCounter);
                saveFeature(id, 'arrow', currentPoints, {color, size, width, dashed}, label, arrowCounter);
                stopDrawing();
            }
        });

        function finishFreehandPolygon() {
            if (currentPoints.length < 2) return;
            const color = document.getElementById('draw-color').value;
            let label = document.getElementById('draw-label').value || "V√πng ho·∫°t ƒë·ªông";
            const isDashed = document.getElementById('poly-dashed').checked;
            const isFill = document.getElementById('poly-fill').checked;
            const id = 'poly-' + Date.now();
            let coords = currentPoints;
            if (isFill) { coords.push(coords[0]); coords = [coords]; }
            try {
                const tempLine = turf.lineString(currentPoints);
                const simplified = turf.simplify(tempLine, {tolerance: 0.005, highQuality: false});
                let finalGeoCoords = simplified.geometry.coordinates;
                if (isFill) {
                     finalGeoCoords.push(finalGeoCoords[0]);
                     coords = [finalGeoCoords];
                     addPolygonToMap(finalGeoCoords, color, 0.5, id, isDashed);
                } else {
                     coords = finalGeoCoords;
                     map.addSource(id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: coords } } });
                     map.addLayer({ id: id + '-outline', type: 'line', source: id, paint: { 'line-color': color, 'line-width': 3, 'line-dasharray': isDashed ? [2, 2] : [1, 0] } });
                }
                saveFeature(id, 'polygon', coords, {color, opacity: 0.5, isDashed, isFill}, label, 0);
            } catch (e) { console.error(e); }
            stopDrawing();
        }

        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || e.target.classList.contains('safe-input')) return; 
            if ((e.key === 'x' || e.key === 'X')) {
                if (currentDrawType === 'delete' && pendingDeleteId) {
                     if (suppressDeleteWarning) executeDelete(); else document.getElementById('delete-confirm-modal').style.display = 'flex';
                } else if (selectedFeatureId) {
                    pendingDeleteId = selectedFeatureId;
                    if (suppressDeleteWarning) executeDelete(); else document.getElementById('delete-confirm-modal').style.display = 'flex';
                }
            }
            if (selectedFeatureId) {
                const speed = 2; 
                if (e.key === 'ArrowUp') moveSelectedFeature(0, speed);
                if (e.key === 'ArrowDown') moveSelectedFeature(0, -speed);
                if (e.key === 'ArrowLeft') moveSelectedFeature(-speed, 0);
                if (e.key === 'ArrowRight') moveSelectedFeature(speed, 0);
            }
            if (e.key === 'u' || e.key === 'U') {
                const chk = document.getElementById('chk-glow-effect'); chk.checked = !chk.checked; toggleGlowMode();
            }
            if (e.key === 'z' || e.key === 'Z') isBending = true;
            if (e.key === 'Escape') {
                if (currentDrawType === 'delete' || isDrawing) {
                    document.getElementById('draw-mode').value = 'none'; updateUI(); toggleDrawing(); 
                } 
                selectFeature(null);
                document.getElementById('delete-confirm-modal').style.display = 'none';
            }
            if (e.key.toLowerCase() === 't') changeTimeline(1);
            if (e.key.toLowerCase() === 'y') changeTimeline(-1);
            
            if (selectedFeatureId) {
                if (e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 'd') {
                    const feature = mapData.features.find(f=>f.id === selectedFeatureId);
                    if(feature) {
                        const el = document.getElementById(feature.id + (feature.type==='arrow' ? '-head' : ''));
                        const icon = el ? el.querySelector('i') : null;
                        if(icon) {
                            let currentRot = 0;
                            const st = window.getComputedStyle(icon);
                            const tm = st.getPropertyValue("-webkit-transform") || st.getPropertyValue("transform");
                            if(tm !== 'none') {
                                const values = tm.split('(')[1].split(')')[0].split(',');
                                currentRot = Math.round(Math.atan2(values[1], values[0]) * (180/Math.PI));
                            }
                            const step = e.key.toLowerCase() === 'a' ? -5 : 5;
                            const newRot = currentRot + step;
                            icon.style.transform = `rotate(${newRot}deg)`;
                            feature.style.rotation = newRot; 
                        }
                    }
                }
            }
        });
        document.addEventListener('keyup', (e) => { if (e.key === 'z' || e.key === 'Z') isBending = false; });

        function handleBending(e) {
            if (isBending && selectedFeatureId) {
                const feature = mapData.features.find(f => f.id === selectedFeatureId);
                if (feature && feature.type === 'arrow') {
                    const originalCoords = feature.data; 
                    const start = originalCoords[0];
                    const end = originalCoords[originalCoords.length - 1];
                    const mouse = [e.lngLat.lng, e.lngLat.lat];
                    const line = turf.lineString([start, mouse, end]);
                    const curved = turf.bezierSpline(line, { resolution: 10000, sharpness: 0.6 });
                    map.getSource(feature.id).setData(curved);
                    feature.data = curved.geometry.coordinates; 
                }
            }
        }

        function updateTempLayer(type) {
            const data = { type: 'Feature', geometry: { type: type === 'line' ? 'LineString' : 'Polygon', coordinates: currentPoints } };
            if (map.getSource(tempId)) { map.getSource(tempId).setData(data); }
            else {
                map.addSource(tempId, { type: 'geojson', data: data });
                map.addLayer({ id: tempId, type: 'line', source: tempId, paint: { 'line-color': '#c0392b', 'line-width': 3 } });
            }
        }

        function addArrowToMap(coords, color, headSize, lineWidth, dashed, id, order, rotation) {
            map.addSource(id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: coords } } });
            map.addLayer({
                id: id, type: 'line', source: id,
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: { 'line-color': color, 'line-width': parseInt(lineWidth), 'line-dasharray': dashed ? [2, 2] : [1, 0] }
            });
            const last = coords[coords.length - 1]; const prev = coords[coords.length - 2];
            let bearing = turf.bearing(turf.point(prev), turf.point(last));
            const iconSize = parseInt(headSize) * 6;
            const el = document.createElement('div'); 
            el.className = `map-feature feature-arrow arrow-order-${order}`; 
            el.id = id + '-head';
            el.innerHTML = `<i class="fas fa-long-arrow-alt-up" style="color: ${color}; font-size: ${iconSize}px; display:block; text-shadow:0 0 2px white;"></i>`;
            el.style.cursor = 'pointer'; 
            const finalRot = (rotation !== undefined) ? rotation : bearing;
            el.querySelector('i').style.transform = `rotate(${finalRot}deg)`;
            
            // FIX: Arrow Head adheres to Map (rotation & pitch)
            const marker = new maplibregl.Marker({ element: el, rotationAlignment: 'map', pitchAlignment: 'map' }).setLngLat(last).addTo(map);
            markers[id] = marker; 

            el.addEventListener('click', (e) => {
                e.stopPropagation();
                if (currentDrawType === 'delete') { trySelectForDelete(id, el); } else { selectFeature(id); }
            });
            return marker;
        }

        function addPolygonToMap(coords, color, opacity, id, isDashed) {
            map.addSource(id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'Polygon', coordinates: [coords] } } });
            map.moveLayer(id + '-fill', 'vn-border-line'); 
            map.addLayer({ id: id + '-fill', type: 'fill', source: id, paint: { 'fill-color': color, 'fill-opacity': opacity } }, 'layer-separator');
            map.addLayer({ id: id + '-outline', type: 'line', source: id, paint: { 'line-color': color, 'line-width': 2, 'line-dasharray': isDashed ? [2, 2] : [1, 0] } }, 'vn-border-line');
        }

        function addIconMarker(lngLat, icon, color, size, label, id, rotation) {
            const el = document.createElement('div'); el.className = `map-feature`; el.id = id;
            const px = parseInt(size) * 8; 
            el.innerHTML = `<i class="fas fa-${icon}" style="color:${color}; font-size:${px}px; text-shadow: 1px 1px 1px black;"></i>`;
            if(rotation !== undefined) { el.querySelector('i').style.transform = `rotate(${rotation}deg)`; }

            // FIX: Normal Icons adhere to Viewport (Always upright)
            // Default behavior of Marker is 'auto' ('viewport'), so we just don't set rotationAlignment.
            const marker = new maplibregl.Marker({ element: el }).setLngLat(lngLat).addTo(map);
            markers[id] = marker; 

            const currentZoom = map.getZoom();
            const scaleFactor = Math.max(0.5, Math.pow(1.3, currentZoom - 7.2));
            el.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
            
            el.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                if (currentDrawType === 'delete') { trySelectForDelete(id, el); } else { selectFeature(id); }
            });
            return marker;
        }

        function addTextMarker(lngLat, text, color, size, font, bold, italic, id) {
            const el = document.createElement('div'); el.className = `custom-text-marker`; el.id = id;
            el.style.color = color; el.style.fontSize = (parseInt(size) * 5) + 'px'; el.style.fontFamily = font; el.style.fontWeight = bold ? 'bold' : 'normal'; el.style.fontStyle = italic ? 'italic' : 'normal'; el.innerText = text; el.style.cursor = 'pointer';
            const marker = new maplibregl.Marker({ element: el }).setLngLat(lngLat).addTo(map);
            markers[id] = marker; 
            const currentZoom = map.getZoom();
            const scaleFactor = Math.max(0.5, Math.pow(1.3, currentZoom - 7.2));
            el.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
            el.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                if (currentDrawType === 'delete') { trySelectForDelete(id, el); } else { selectFeature(id); }
            });
            return marker;
        }

        function saveFeature(id, type, data, style, label, order) {
            const feat = { id, type, data, style, label, order };
            const existingIdx = mapData.features.findIndex(f => f.id === id);
            if (existingIdx > -1) { mapData.features[existingIdx] = feat; } else { mapData.features.push(feat); }
            renderTimelineTable();
        }

        function renderTimelineTable() {
            const tbody = document.getElementById('timeline-list'); tbody.innerHTML = '';
            // FIX: Allow both Arrows and Markers in Timeline
            const items = mapData.features.filter(f => f.type === 'arrow' || f.type === 'marker').sort((a,b) => a.order - b.order);
            items.forEach(feat => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td align="center"><input type="number" class="order-input" value="${feat.order}" onchange="updateFeatureOrder('${feat.id}', this.value)"></td>
                    <td><input type="text" class="name-input" value="${feat.label}" onchange="updateFeatureLabel('${feat.id}', this.value)"></td>
                    <td align="center"><i class="fas fa-trash" style="cursor:pointer; color:#e74c3c;" onclick="confirmDeleteFromTable('${feat.id}')"></i></td>
                `;
                tbody.appendChild(tr);
            });
            updateVisibility();
        }
        window.updateFeatureOrder = function(id, newOrderVal) {
            let newOrder = parseInt(newOrderVal); if(isNaN(newOrder) || newOrder < 0) newOrder = 0;
            const feature = mapData.features.find(f => f.id === id);
            if(feature) { feature.order = newOrder; if(newOrder > arrowCounter) arrowCounter = newOrder; renderTimelineTable(); }
        }
        window.updateFeatureLabel = function(id, newLabel) {
            const feature = mapData.features.find(f => f.id === id);
            if(feature) { feature.label = newLabel; }
        }
        function confirmDeleteFromTable(id) { pendingDeleteId = id; if (suppressDeleteWarning) executeDelete(); else document.getElementById('delete-confirm-modal').style.display = 'flex'; }
        
        function deleteFeature(id) {
            if(map.getLayer(id)) map.removeLayer(id); 
            if(map.getLayer(id+'-fill')) map.removeLayer(id+'-fill'); 
            if(map.getLayer(id+'-outline')) map.removeLayer(id+'-outline'); 
            if(map.getSource(id)) map.removeSource(id);
            const el = document.getElementById(id); if(el) el.remove(); 
            const headEl = document.getElementById(id+'-head'); if(headEl) headEl.remove();
            if(markers[id]) { markers[id].remove(); delete markers[id]; }
            if(selectedFeatureId === id) selectFeature(null);
            mapData.features = mapData.features.filter(f => f.id !== id); 
            renderTimelineTable();
        }

        function executeDelete() { if (pendingDeleteId) { deleteFeature(pendingDeleteId); pendingDeleteId = null; } }

        function handleDeleteSelection(e) {
             const point = e.point; clearDeleteSelection();
             const arrowFeatures = map.queryRenderedFeatures(point, { layers: mapData.features.filter(f=>f.type==='arrow').map(f=>f.id) });
             if (arrowFeatures.length > 0) { selectForDelete(arrowFeatures[0].layer.id); return; }
             const polyFeatures = map.queryRenderedFeatures(point, { layers: mapData.features.filter(f=>f.type==='polygon').map(f=>f.id + '-fill') });
             if (polyFeatures.length > 0) { selectForDelete(polyFeatures[0].layer.id.replace('-fill', '')); return; }
        }
        
        function trySelectForDelete(id, element) {
             clearDeleteSelection(); pendingDeleteId = id; element.classList.add('selected-danger');
             new maplibregl.Popup({closeButton:false, closeOnClick:true, offset: 25}).setLngLat(map.getCenter()).setHTML('<div style="color:red; font-weight:bold;">Nh·∫•n X ƒë·ªÉ x√≥a</div>').addTo(map);
        }
        function selectForDelete(id) {
             pendingDeleteId = id; map.setPaintProperty(id, 'line-color', '#ff0000');
             new maplibregl.Popup({closeButton:false}).setLngLat(map.getCenter()).setHTML('<div style="color:red; font-weight:bold;">Nh·∫•n X ƒë·ªÉ x√≥a</div>').addTo(map);
        }
        function clearDeleteSelection() { }

        function changeTimeline(val) {
            if (currentTimelineStep === 999 && val === 1) currentTimelineStep = 0; 
            currentTimelineStep += val; if (currentTimelineStep < 0) currentTimelineStep = 0; 
            if (currentTimelineStep > arrowCounter + 5) currentTimelineStep = 999;
            document.getElementById('current-step-display').innerText = currentTimelineStep === 999 ? "Hi·ªán t·∫•t c·∫£" : `B∆∞·ªõc: ${currentTimelineStep}`;
            updateVisibility();
            playMarchingSound();
        }
        function showAllTimeline() { currentTimelineStep = 999; document.getElementById('current-step-display').innerText = "Hi·ªán t·∫•t c·∫£"; updateVisibility(); }
        function toggleGlowMode() { isGlowingEnabled = document.getElementById('chk-glow-effect').checked; updateVisibility(); }
        
        function updateVisibility() {
            mapData.features.forEach(feat => {
                const step = feat.order;
                const isVisible = (currentTimelineStep === 999) || (step <= currentTimelineStep);
                
                // Arrows
                if (feat.type === 'arrow') {
                    if (map.getLayer(feat.id)) {
                        map.setLayoutProperty(feat.id, 'visibility', isVisible ? 'visible' : 'none');
                        if (isVisible && isGlowingEnabled && currentTimelineStep !== 999 && step !== currentTimelineStep) {
                             map.setPaintProperty(feat.id, 'line-color', '#555555'); map.setPaintProperty(feat.id, 'line-opacity', 0.4);
                        } else if (isVisible) {
                             map.setPaintProperty(feat.id, 'line-color', feat.style.color); map.setPaintProperty(feat.id, 'line-opacity', 1);
                        }
                    }
                    const head = document.getElementById(feat.id + '-head');
                    if (head) {
                        head.style.display = isVisible ? 'block' : 'none';
                        head.classList.remove('feature-dimmed');
                        if (isVisible && isGlowingEnabled && currentTimelineStep !== 999 && step !== currentTimelineStep) {
                            head.classList.add('feature-dimmed');
                        }
                    }
                }
                // Markers (Icons)
                else if (feat.type === 'marker') {
                    const el = document.getElementById(feat.id);
                    if(el) {
                        el.style.display = isVisible ? 'flex' : 'none'; // Marker uses flex center
                        el.classList.remove('feature-dimmed');
                        if (isVisible && isGlowingEnabled && currentTimelineStep !== 999 && step !== currentTimelineStep && step > 0) {
                            el.classList.add('feature-dimmed');
                        }
                    }
                }
            });
        }

        // ... (Static Legend & Export functions unchanged) ...
        function createStaticLegend() {
            const container = document.getElementById('static-legend-container');
            const items = [
                { icon: '<i class="fas fa-fire" style="color:#e67e22"></i>', text: 'N∆°i L√™ L·ª£i d·ª±ng c·ªù', type: 'marker', color: '#e67e22', iconName: 'fire' },
                { icon: '<i class="fas fa-mountain" style="color:#5d4037"></i> <i class="fas fa-long-arrow-alt-right" style="color:#c0392b; border-bottom: 2px dashed #c0392b"></i>', text: 'Nghƒ©a qu√¢n r√∫t l√™n n√∫i', type: 'arrow', color: '#c0392b', dashed: true },
                { icon: '<i class="fas fa-long-arrow-alt-right" style="color:#c0392b; transform: rotate(-45deg);"></i>', text: 'H∆∞·ªõng ti·∫øn c·ªßa nghƒ©a qu√¢n', type: 'arrow', color: '#c0392b', dashed: false },
                { icon: '<i class="fas fa-location-arrow" style="color:#c0392b"></i>', text: 'Nghƒ©a qu√¢n ch·∫∑n ƒë√°nh', type: 'marker', color: '#c0392b', iconName: 'location-arrow' },
                { icon: '<i class="fas fa-times" style="color:#c0392b"></i>', text: 'N∆°i ti√™u di·ªát ƒë·ªãch', type: 'marker', color: '#c0392b', iconName: 'times' },
                { icon: '<i class="fas fa-star" style="color:#f1c40f"></i>', text: 'N∆°i ƒë√°nh b·∫°i qu√¢n Minh', type: 'marker', color: '#f1c40f', iconName: 'star' },
                { icon: '<i class="fas fa-chess-rook" style="color:#7f8c8d"></i>', text: 'Th√†nh qu√¢n Minh b·ªã v√¢y', type: 'marker', color: '#7f8c8d', iconName: 'chess-rook' },
                { icon: '<i class="fas fa-long-arrow-alt-right" style="color:#2980b9; border-bottom:2px dashed #2980b9;"></i>', text: 'Qu√¢n Minh r√∫t ch·∫°y', type: 'arrow', color: '#2980b9', dashed: true },
                { icon: '<div style="width:14px;height:14px;background:#eab676;opacity:0.8;border:1px solid #d35400"></div>', text: 'V√πng ho·∫°t ƒë·ªông 1418-1423', type: 'polygon', color: '#eab676', dashed: false },
                { icon: '<div style="width:14px;height:14px;background:#a2d9a2;opacity:0.8;border:1px solid #27ae60"></div>', text: 'V√πng gi·∫£i ph√≥ng 1424-1425', type: 'polygon', color: '#a2d9a2', dashed: false },
                { icon: '<div style="width:14px;height:14px;background:#c3e6cb;opacity:0.8;border:1px solid #2ecc71"></div>', text: 'V√πng gi·∫£i ph√≥ng 1426-1427', type: 'polygon', color: '#c3e6cb', dashed: false },
                { icon: '<div style="width:20px;height:0px;border-top:2px dashed #000;"></div>', text: 'Bi√™n gi·ªõi qu·ªëc gia', type: 'none', color: '#000' }
            ];
            items.forEach(item => {
                const div = document.createElement('div'); div.className = 'legend-row';
                div.innerHTML = `<div class="l-icon">${item.icon}</div><div class="l-text">${item.text}</div>`;
                if(item.type !== 'none') {
                    div.title = "Click ƒë·ªÉ ch·ªçn v·∫Ω lo·∫°i n√†y";
                    div.onclick = () => {
                        document.getElementById('draw-mode').value = item.type; document.getElementById('draw-color').value = item.color;
                        if(item.type === 'arrow') document.getElementById('draw-dashed').checked = item.dashed;
                        if(item.type === 'marker') selectIcon(item.iconName);
                        updateUI(); if(!isDrawing) toggleDrawing();
                    };
                }
                container.appendChild(div);
            });
        }
        function toggleLegend() { const leg = document.getElementById('floating-legend'); const icon = document.getElementById('legend-icon'); leg.classList.toggle('minimized'); icon.className = leg.classList.contains('minimized') ? "fas fa-chevron-up" : "fas fa-chevron-down"; }
        function toggleMapLabels() {
            let labelsVisible = document.getElementById('label-toggle-btn').style.color !== 'rgb(170, 170, 170)'; labelsVisible = !labelsVisible;
            const btn = document.getElementById('label-toggle-btn'); btn.innerHTML = labelsVisible ? '<i class="fas fa-font"></i>' : '<i class="fas fa-slash"></i>'; btn.style.color = labelsVisible ? 'white' : '#aaa';
            const layers = map.getStyle().layers; layers.forEach(layer => { if (layer.type === 'symbol') map.setLayoutProperty(layer.id, 'visibility', labelsVisible ? 'visible' : 'none'); });
        }
        function selectIcon(name) { selectedIcon = name; document.querySelectorAll('.icon-option').forEach(el=>el.classList.remove('selected')); event.currentTarget.classList.add('selected'); }
        function updateUI() {
            const mode = document.getElementById('draw-mode').value;
            if (mode === 'delete') { document.getElementById('options-panel').style.display = 'none'; return; }
            document.getElementById('options-panel').style.display = mode === 'none' ? 'none' : 'block';
            // FIX: Ensure icon-options is shown correctly
            document.getElementById('icon-options').style.display = mode === 'marker' ? 'grid' : 'none'; // Grid instead of block
            document.getElementById('text-options').style.display = mode === 'text' ? 'block' : 'none';
            document.getElementById('arrow-specific-options').style.display = mode === 'arrow' ? 'block' : 'none';
            document.getElementById('polygon-specific-options').style.display = mode === 'polygon' ? 'block' : 'none';
        }
        function exportJSON() { const blob = new Blob([JSON.stringify(mapData)], {type: "application/json"}); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = "tactical_map_v21.json"; link.click(); }
        function importJSON(input) {
            const file = input.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    mapData.features.forEach(f => deleteFeature(f.id));
                    mapData = { features: [] }; arrowCounter = 0; markers = {}; 
                    data.features.forEach(f => {
                        if (f.order > arrowCounter) arrowCounter = f.order;
                        if (f.type === 'arrow') {
                            addArrowToMap(f.data, f.style.color, f.style.size, f.style.width || 4, f.style.dashed, f.id, f.order, f.style.rotation);
                            saveFeature(f.id, 'arrow', f.data, f.style, f.label, f.order);
                        } else if (f.type === 'marker') {
                            addIconMarker({lng: f.data.lng, lat: f.data.lat}, f.data.icon, f.style.color, f.style.size, f.label, f.id, f.style.rotation);
                            saveFeature(f.id, 'marker', f.data, f.style, f.label, f.order || 0); // Include order
                        } else if (f.type === 'text') {
                            if(f.data && f.data.lng) {
                                addTextMarker({lng: f.data.lng, lat: f.data.lat}, f.data.text, f.style.color, f.style.size, f.style.font, f.style.isBold, f.style.isItalic, f.id);
                                saveFeature(f.id, 'text', f.data, f.style, f.label, 0);
                            }
                        } else if (f.type === 'polygon') {
                            if (f.style.isFill) {
                                let inputCoords = f.data;
                                if(Array.isArray(f.data) && Array.isArray(f.data[0]) && Array.isArray(f.data[0][0])) inputCoords = f.data[0];
                                addPolygonToMap(inputCoords, f.style.color, f.style.opacity, f.id, f.style.isDashed);
                            } else {
                                map.addSource(f.id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: f.data } } });
                                map.addLayer({ id: f.id + '-outline', type: 'line', source: f.id, paint: { 'line-color': f.style.color, 'line-width': 3, 'line-dasharray': f.style.isDashed ? [2, 2] : [1, 0] } });
                            }
                            saveFeature(f.id, 'polygon', f.data, f.style, f.label, 0);
                        }
                    });
                    setTimeout(updateMarkerScales, 100); alert("ƒê√£ t·∫£i b·∫£n ƒë·ªì th√†nh c√¥ng!");
                } catch (err) { console.error(err); alert("L·ªói file kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng."); }
            };
            reader.readAsText(file); input.value = '';
        }
    </script>
</body>
</html>
