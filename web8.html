<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B·∫£n ƒê·ªì Chi·∫øn Thu·∫≠t - Tactical Editor v13 (Edit & Layers)</title>
    
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    
    <script src="https://unpkg.com/@turf/turf@6.5.0/turf.min.js"></script>
    
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&family=Merriweather:ital,wght@0,400;0,700;1,400&family=Roboto:wght@400;700&display=swap" rel="stylesheet">

    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; font-family: 'Roboto', sans-serif; background-color: #e0d5b0; }
        
        #map { width: 100%; height: 100%; position: absolute; top: 0; left: 0; z-index: 1; }

        /* --- SIDEBAR --- */
        #sidebar {
            width: 360px; height: 100vh;
            color: #dcdcdc; padding: 15px; box-sizing: border-box;
            transition: transform 0.3s ease;
            position: absolute; z-index: 1000; left: 0; top: 0; background: #2b2b2b;
            overflow-y: auto; box-shadow: 4px 0 15px rgba(0,0,0,0.6);
            border-right: 3px solid #8b4513;
            display: flex; flex-direction: column; gap: 12px;
        }
        #sidebar.collapsed { transform: translateX(-370px); }

        h2 { margin: 0; font-family: 'Cinzel', serif; font-size: 22px; text-align: center; color: #f39c12; border-bottom: 2px solid #8b4513; padding-bottom: 10px; text-shadow: 1px 1px 2px black; letter-spacing: 1px; }
        h3 { margin: 0; border-bottom: 1px solid #555; padding-bottom: 5px; font-size: 14px; color: #f1c40f; text-transform: uppercase; letter-spacing: 1px; }

        .control-group { background: rgba(255,255,255,0.05); padding: 10px; border-radius: 6px; border: 1px solid #444; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 13px; color: #aaa; }
        
        input, select, button { width: 100%; margin-bottom: 8px; padding: 8px; border-radius: 4px; border: 1px solid #555; background: #3c3c3c; color: white; font-size: 13px; }
        input[type="checkbox"] { width: auto; margin-right: 5px; vertical-align: middle; }
        
        button.btn-action { background: #5d4037; font-weight: bold; border: 1px solid #8d6e63; cursor: pointer; color: #f1c40f; }
        button.btn-action:hover { background: #795548; }

        /* Icon Grid */
        .icon-grid { display: grid; grid-template-columns: repeat(4, 1fr); gap: 5px; }
        .icon-option { background: #4a3b32; border: 1px solid #6d4c41; padding: 8px; text-align: center; cursor: pointer; border-radius: 4px; }
        .icon-option.selected { background: #f1c40f; color: #2c3e50; border-color: #fff; box-shadow: 0 0 8px #f1c40f; }
        
        .help-box { font-size: 12px; color: #bdc3c7; background: rgba(0,0,0,0.3); padding: 8px; border-radius: 4px; line-height: 1.5; border-left: 3px solid #e74c3c; }
        .help-key { display: inline-block; background: #eee; color: #333; padding: 0 4px; border-radius: 2px; font-weight: bold; font-family: monospace; font-size: 10px; }

        .top-right-controls {
            position: absolute; top: 15px; right: 15px; display: flex; flex-direction: column; gap: 5px; 
            z-index: 9999; pointer-events: auto;
        }

        #toggle-btn, #label-toggle-btn {
            width: 36px; height: 36px; 
            background: #8b4513; color: white; border: 2px solid #d35400; cursor: pointer; border-radius: 4px;
            display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.5);
            position: relative; top: auto; right: auto;
        }
        #label-toggle-btn { background: #2c3e50; border-color: #34495e; }

        .timeline-table { width: 100%; font-size: 12px; border-collapse: collapse; }
        .timeline-table td { padding: 4px; border-bottom: 1px solid #444; vertical-align: middle; }
        .order-input { width: 40px; text-align: center; background: #222; border: 1px solid #555; color: #f1c40f; font-weight: bold; padding: 2px; margin: 0; }
        .name-input { width: 100%; background: transparent; border: none; color: #dcdcdc; font-family: inherit; }
        .name-input:focus { border-bottom: 1px solid #f1c40f; outline: none; }

        #floating-legend {
            position: absolute; bottom: 20px; right: 20px;
            width: 350px; max-height: 60vh;
            background: rgba(255, 255, 255, 0.98);
            border: 2px solid #8b4513; border-radius: 5px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.4); z-index: 2000;
            overflow: hidden; 
            color: #333; font-family: 'Merriweather', serif;
            transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
            transform-origin: bottom right;
        }
        #floating-legend.minimized { transform: translateY(calc(100% - 36px)); }
        
        .legend-header {
            background: #8b4513; color: #f1c40f; padding: 10px; font-weight: bold;
            display: flex; justify-content: space-between; align-items: center; cursor: pointer;
            font-size: 13px; text-transform: uppercase; user-select: none;
        }
        .legend-body { padding: 5px; overflow-y: auto; max-height: calc(60vh - 40px); }
        .legend-row { display: flex; align-items: center; gap: 10px; padding: 6px; border-bottom: 1px solid #eee; cursor: pointer; transition: background 0.2s; }
        .legend-row:hover { background: #f0e6d2; }
        .l-icon { width: 30px; text-align: center; display: flex; justify-content: center; align-items: center; }
        .l-text { flex: 1; font-size: 11px; line-height: 1.3; font-weight: bold; color: #555; }
        
        .map-feature i { filter: sepia(0.4) drop-shadow(0px 2px 2px rgba(0,0,0,0.8)); }
        .bend-popup { font-size: 11px; color: #333; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.6); display: flex; justify-content: center; align-items: center; z-index: 9999;
        }
        .modal-content {
            background: white; padding: 20px; border-radius: 8px; width: 320px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5); font-family: Arial, sans-serif;
        }
        .modal-content h3 { color: #d9534f; margin-top: 0; border-bottom: none; font-size: 18px; text-align: left; }
        .modal-buttons { margin-top: 20px; display: flex; justify-content: flex-end; gap: 10px; }
        .btn-danger { background: #d9534f; color: white; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; width: auto; }
        .btn-secondary { background: #ccc; color: black; border: none; padding: 8px 15px; border-radius: 4px; cursor: pointer; width: auto; }
        
        /* Hi·ªáu ·ª©ng ch·ªçn ƒë·ªÉ s·ª≠a */
        .selected-edit { outline: 3px dashed #00b894 !important; box-shadow: 0 0 15px #00b894; }
        .selected-danger { outline: 3px dashed red !important; border-radius: 4px; box-shadow: 0 0 10px red; background: rgba(255, 0, 0, 0.2); }

        .feature-dimmed i {
            filter: grayscale(100%) brightness(0.3) opacity(0.4) !important;
            transition: filter 0.3s ease;
        }

        .map-feature {
            position: absolute; top: 0; left: 0;
            display: flex; justify-content: center; align-items: center;
            transform: translate(-50%, -50%); 
            pointer-events: auto;
        }

        .custom-text-marker { 
            position: absolute; top: 0; left: 0;
            text-shadow: 1px 1px 0 #000; 
            white-space: nowrap; 
            transform: translate(-50%, -50%); 
            pointer-events: auto; background: transparent;
        }
    </style>
</head>
<body>

    <div class="top-right-controls">
        <button id="toggle-btn" title="ƒê√≥ng/M·ªü B·∫£ng C√¥ng C·ª•"><i class="fas fa-bars"></i></button>
        <button id="label-toggle-btn" title="·∫®n/Hi·ªán T√™n ƒê·ªãa Danh"><i class="fas fa-font"></i></button>
    </div>

    <div id="sidebar">
        <h2>B·∫¢NG C√îNG C·ª§ V·∫º</h2>
        <div class="control-group">
            <h3><i class="fas fa-info-circle"></i> H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng</h3>
            <div class="help-box">
                <b>1. CH·ªàNH S·ª¨A:</b> Click v√†o ƒë·ªëi t∆∞·ª£ng b·∫•t k·ª≥ ƒë·ªÉ ch·ªçn (Vi·ªÅn xanh). Thay ƒë·ªïi m√†u/size ·ªü b·∫£ng b√™n d∆∞·ªõi s·∫Ω c·∫≠p nh·∫≠t ngay.<br>
                <b>2. XOAY M≈®I T√äN:</b> Ch·ªçn m≈©i t√™n -> D√πng ph√≠m <span class="help-key">‚¨ÖÔ∏è</span> <span class="help-key">‚û°Ô∏è</span> ƒë·ªÉ xoay to√†n b·ªô.<br>
                <b>3. XOAY ICON:</b> Ch·ªçn icon -> D√πng ph√≠m <span class="help-key">A</span> (Tr√°i) / <span class="help-key">D</span> (Ph·∫£i).<br>
                <b>4. V·∫º V√ôNG:</b> V·∫Ω xong v√πng s·∫Ω t·ª± ƒë·ªông n·∫±m d∆∞·ªõi c√°c l·ªõp kh√°c.<br>
                <b>5. B·∫∫ CONG:</b> Gi·ªØ <span class="help-key">Z</span> + Di chu·ªôt (ch·ªâ ho·∫°t ƒë·ªông khi kh√¥ng ·ªü ch·∫ø ƒë·ªô v·∫Ω).<br>
                <b>6. X√ìA:</b> Ch·ªçn ƒë·ªëi t∆∞·ª£ng -> Nh·∫•n <span class="help-key">X</span>.
            </div>
        </div>

        <div class="control-group">
            <h3>C√¥ng C·ª• Chi·∫øn Thu·∫≠t</h3>
            <select id="draw-mode" onchange="updateUI()">
                <option value="none">-- Ch·ªçn Ch·∫ø ƒê·ªô --</option>
                <option value="arrow">M≈©i T√™n (Chi·∫øn d·ªãch)</option>
                <option value="marker">Bi·ªÉu T∆∞·ª£ng (Icon)</option>
                <option value="text">VƒÉn B·∫£n (Ghi ch√∫)</option>
                <option value="polygon">V√πng / N√©t v·∫Ω t·ª± do</option>
                <option value="delete" style="color: #e74c3c; font-weight: bold;">üóëÔ∏è Ch·∫ø ƒë·ªô X√≥a (Ph√≠m X)</option>
            </select>
            <button class="btn-action" id="action-btn" onclick="toggleDrawing()">B·∫Øt ƒë·∫ßu v·∫Ω</button>
        </div>

        <div id="options-panel">
            <div class="control-group">
                <label>Thu·ªôc t√≠nh (Ch·ªânh s·ª≠a ƒë·ªëi t∆∞·ª£ng ƒëang ch·ªçn):</label>
                <div style="display:flex; gap:5px; align-items:center; flex-wrap: wrap;">
                    <input type="color" id="draw-color" value="#c0392b" style="width:40px; height:30px; padding:0;" oninput="updateSelectedFeatureStyle()">
                    <input type="number" id="draw-size" value="4" min="1" max="50" title="K√≠ch th∆∞·ªõc ƒë·∫ßu m≈©i t√™n/Icon/Ch·ªØ" style="width:50px;" placeholder="Size" oninput="updateSelectedFeatureStyle()">
                    <input type="number" id="draw-width" value="4" min="1" max="20" title="ƒê·ªô d√†y ƒë∆∞·ªùng th·∫≥ng" style="width:50px;" placeholder="D√†y" oninput="updateSelectedFeatureStyle()">
                </div>
                <div id="arrow-specific-options" style="display:none; margin-top:5px;">
                     <label><input type="checkbox" id="draw-dashed"> N√©t ƒë·ª©t (R√∫t lui/B√≠ m·∫≠t)</label>
                </div>
                <div id="polygon-specific-options" style="display:none; margin-top:5px;">
                    <label><input type="checkbox" id="poly-fill" checked> T·ª± ƒë·ªông ƒë·ªï m√†u (Kh√©p k√≠n)</label>
                    <label><input type="checkbox" id="poly-dashed"> Vi·ªÅn n√©t ƒë·ª©t</label>
                </div>
                <input type="text" id="draw-label" placeholder="T√™n (Hi·ªÉn th·ªã trong timeline)..." style="margin-top:5px;">
            </div>

            <div class="control-group" id="icon-options" style="display:none;">
                <label>Bi·ªÉu t∆∞·ª£ng:</label>
                <div class="icon-grid">
                    <div class="icon-option selected" onclick="selectIcon('fire')" title="N∆°i kh·ªüi nghƒ©a"><i class="fas fa-fire" style="color:#e67e22"></i></div>
                    <div class="icon-option" onclick="selectIcon('flag')" title="S·ªü ch·ªâ huy"><i class="fas fa-flag" style="color:#c0392b"></i></div>
                    <div class="icon-option" onclick="selectIcon('star')" title="Chi·∫øn th·∫Øng"><i class="fas fa-star" style="color:#f1c40f"></i></div>
                    <div class="icon-option" onclick="selectIcon('chess-rook')" title="Th√†nh tr√¨"><i class="fas fa-chess-rook" style="color:#7f8c8d"></i></div>
                    <div class="icon-option" onclick="selectIcon('skull')" title="Ti√™u di·ªát"><i class="fas fa-skull" style="color:#fff"></i></div>
                    <div class="icon-option" onclick="selectIcon('campground')" title="Doanh tr·∫°i"><i class="fas fa-campground" style="color:#27ae60"></i></div>
                    <div class="icon-option" onclick="selectIcon('mountain')" title="N√∫i/ƒê·ªãa h√¨nh"><i class="fas fa-mountain" style="color:#5d4037"></i></div>
                    <div class="icon-option" onclick="selectIcon('location-arrow')" title="Ch·∫∑n ƒë√°nh"><i class="fas fa-location-arrow" style="color:#c0392b"></i></div>
                    <div class="icon-option" onclick="selectIcon('times')" title="D·∫•u X (Di·ªát)"><i class="fas fa-times" style="color:#c0392b"></i></div>
                </div>
            </div>

            <div class="control-group" id="text-options" style="display:none;">
                <input type="text" id="text-content" placeholder="N·ªôi dung ch·ªØ...">
                <select id="text-font">
                    <option value="'Merriweather', serif">Merriweather (C·ªï ƒëi·ªÉn)</option>
                    <option value="'Roboto', sans-serif">Roboto (Hi·ªán ƒë·∫°i)</option>
                </select>
                <div style="display:flex; gap:10px;">
                    <label><input type="checkbox" id="text-bold" checked> ƒê·∫≠m</label>
                    <label><input type="checkbox" id="text-italic"> Nghi√™ng</label>
                </div>
            </div>
        </div>

        <div class="control-group">
            <h3>Di·ªÖn Bi·∫øn (Timeline)</h3>
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px;">
                <span id="current-step-display" style="font-size:13px; font-weight:bold; color:#f1c40f;">Hi·ªán t·∫•t c·∫£</span>
                <div style="display:flex; gap: 2px;">
                    <button onclick="changeTimeline(-1)" style="width:30px; margin:0;" title="L√πi (Y)">Y</button>
                    <button onclick="changeTimeline(1)" style="width:30px; margin:0;" title="Ti·∫øn (T)">T</button>
                    <button onclick="showAllTimeline()" style="width:30px; margin:0; background:#f39c12; color:#000;" title="Hi·ªán t·∫•t c·∫£ (M·∫Øt)"><i class="fas fa-eye"></i></button>
                </div>
            </div>
            <label style="font-size:11px; color:#aaa; margin-top:4px;">
                <input type="checkbox" id="chk-glow-effect" onchange="toggleGlowMode()"> B·∫≠t ch·∫ø ƒë·ªô L√†m t·ªëi (·∫®n c√°c b∆∞·ªõc kh√°c) - Ph√≠m U
            </label>
            <div style="max-height: 200px; overflow-y: auto; background: rgba(0,0,0,0.2);">
                <table class="timeline-table">
                    <thead>
                        <tr style="color:#aaa; border-bottom:1px solid #555;">
                            <th align="center" width="40">STT</th>
                            <th align="left">T√™n (S·ª≠a ƒë∆∞·ª£c)</th>
                            <th width="30">X√≥a</th>
                        </tr>
                    </thead>
                    <tbody id="timeline-list"></tbody>
                </table>
            </div>
        </div>
        
        <div class="control-group" style="margin-top:auto;">
             <button class="btn-action" onclick="exportJSON()">L∆∞u B·∫£n ƒê·ªì (JSON)</button>
             <input type="file" id="file-input" style="display: none;" onchange="importJSON(this)">
             <button class="btn-action" style="background:#333; margin-top:5px;" onclick="document.getElementById('file-input').click()">M·ªü B·∫£n ƒê·ªì</button>
        </div>
    </div>

    <div id="floating-legend">
        <div class="legend-header" onclick="toggleLegend()">
            <span><i class="fas fa-map"></i> Ch√∫ Gi·∫£i Qu√¢n S·ª±</span>
            <i class="fas fa-chevron-down" id="legend-icon"></i>
        </div>
        <div class="legend-body" id="static-legend-container"></div>
    </div>

    <div id="map"></div>

    <div id="delete-confirm-modal" class="modal-overlay" style="display: none;">
        <div class="modal-content">
            <h3>‚ö†Ô∏è X√°c nh·∫≠n x√≥a</h3>
            <p>B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ƒë·ªëi t∆∞·ª£ng ƒëang ch·ªçn kh√¥ng?</p>
            <label style="display:block; margin: 10px 0; font-size: 13px; color:#555;">
                <input type="checkbox" id="chk-no-remind"> Kh√¥ng nh·∫Øc l·∫°i
            </label>
            <div class="modal-buttons">
                <button id="btn-confirm-delete" class="btn-danger">X√≥a (X)</button>
                <button id="btn-cancel-delete" class="btn-secondary">H·ªßy (Esc)</button>
            </div>
        </div>
    </div>

    <script>
        // --- 1. CONFIG & INIT ---
        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://demotiles.maplibre.org/style.json', 
            center: [105.4, 19.3], 
            zoom: 7.2, pitch: 0, antialias: true
        });

        let mapData = { features: [] };
        let isDrawing = false;
        let isFreehandDrawing = false;
        let currentDrawType = 'none';
        let currentPoints = [];
        let tempId = 'temp-layer';
        
        let selectedIcon = 'fire';
        
        let selectedFeatureId = null; // ID c·ªßa ƒë·ªëi t∆∞·ª£ng ƒëang ch·ªçn ƒë·ªÉ s·ª≠a
        let isBending = false;

        let currentTimelineStep = 999;
        let arrowCounter = 0;
        let suppressDeleteWarning = false; 
        
        let isGlowingEnabled = false;

        map.on('load', () => {
            // L·ªõp n·ªÅn bi√™n gi·ªõi
            map.addSource('vietnam-border', { type: 'geojson', data: 'https://raw.githubusercontent.com/vietnam-geospatial/vietnam-administrative-boundaries/master/vietnam_boundary.geojson' });
            map.addLayer({ id: 'vn-border-halo', type: 'line', source: 'vietnam-border', paint: { 'line-color': '#f1c40f', 'line-width': 6, 'line-opacity': 0.4 } });
            map.addLayer({ id: 'vn-border-line', type: 'line', source: 'vietnam-border', paint: { 'line-color': '#8b4513', 'line-width': 2 } });
            
            // T·∫°o l·ªõp ngƒÉn c√°ch ƒë·ªÉ ƒë·∫©y polygon xu·ªëng d∆∞·ªõi
            map.addLayer({ id: 'layer-separator', type: 'background', layout: { 'visibility': 'visible' }, paint: { 'background-color': 'rgba(0,0,0,0)' } });
            
            createStaticLegend();
            
            document.getElementById('toggle-btn').addEventListener('click', function() {
                document.getElementById('sidebar').classList.toggle('collapsed');
            });
            document.getElementById('label-toggle-btn').addEventListener('click', function() {
                toggleMapLabels();
            });
        });

        // --- INTERACTION ---
        function toggleDrawing() {
            isDrawing = !isDrawing;
            const btn = document.getElementById('action-btn');
            currentDrawType = document.getElementById('draw-mode').value;
            
            if(currentDrawType === 'delete') {
                isDrawing = true; 
                btn.innerText = "THO√ÅT CH·∫æ ƒê·ªò X√ìA (ESC)"; btn.style.background = "#d35400"; btn.style.color = "white";
                map.getCanvas().style.cursor = 'not-allowed'; 
                selectFeature(null); // B·ªè ch·ªçn khi v√†o mode x√≥a
            }
            else if(isDrawing) {
                btn.innerText = "D·ª™NG V·∫º (ESC)"; 
                map.getCanvas().style.cursor = 'crosshair';
                map.dragPan.enable();
                if (currentDrawType === 'polygon') map.dragPan.disable();
                btn.style.background = "#c0392b"; btn.style.color = "white";
                selectFeature(null);
            } else {
                stopDrawing();
            }
        }

        function stopDrawing() {
            isDrawing = false; isFreehandDrawing = false; currentPoints = [];
            const btn = document.getElementById('action-btn');
            btn.innerText = "B·∫Øt ƒë·∫ßu v·∫Ω"; btn.style.background = "#5d4037"; btn.style.color = "#f1c40f";
            map.getCanvas().style.cursor = '';
            map.dragPan.enable();
            if(map.getLayer(tempId)) map.removeLayer(tempId);
            if(map.getSource(tempId)) map.removeSource(tempId);
        }

        map.on('mousedown', (e) => {
            if (!isDrawing) return;
            if (currentDrawType === 'polygon') {
                isFreehandDrawing = true;
                currentPoints = [[e.lngLat.lng, e.lngLat.lat]];
                updateTempLayer('line');
            }
        });

        map.on('mousemove', (e) => {
            if (!isDrawing && !isFreehandDrawing) { handleBending(e); return; }
            if (isDrawing && currentDrawType === 'polygon' && isFreehandDrawing) {
                currentPoints.push([e.lngLat.lng, e.lngLat.lat]);
                updateTempLayer('line');
            }
        });

        map.on('mouseup', (e) => {
            if (isDrawing && currentDrawType === 'polygon' && isFreehandDrawing) {
                isFreehandDrawing = false;
                finishFreehandPolygon();
            }
        });

        function updateMarkerScales() {
            const currentZoom = map.getZoom();
            const scaleFactor = Math.max(0.5, Math.pow(1.3, currentZoom - 7.2));
            document.querySelectorAll('.map-feature, .custom-text-marker').forEach(el => {
                el.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;
            });
        }
        map.on('zoom', updateMarkerScales);

        // --- SELECTION & EDITING ---
        function selectFeature(id) {
            // X√≥a highlight c≈©
            if (selectedFeatureId) {
                const oldEl = document.getElementById(selectedFeatureId);
                if (oldEl) oldEl.classList.remove('selected-edit', 'selected-danger');
                if (selectedFeatureId.startsWith('arrow-') || selectedFeatureId.startsWith('poly-')) {
                    // Reset paint n·∫øu c·∫ßn (tuy nhi√™n ta d√πng highlight class cho marker ƒë·∫ßu m≈©i t√™n)
                    const head = document.getElementById(selectedFeatureId + '-head');
                    if(head) head.classList.remove('selected-edit');
                }
            }

            selectedFeatureId = id;

            if (id) {
                const feature = mapData.features.find(f => f.id === id);
                if (feature) {
                    // Update Inputs values
                    document.getElementById('draw-color').value = feature.style.color || '#000000';
                    document.getElementById('draw-size').value = feature.style.size || 4;
                    document.getElementById('draw-width').value = feature.style.width || 4;
                    
                    // Highlight UI
                    const el = document.getElementById(id);
                    if(el) el.classList.add('selected-edit');
                    const head = document.getElementById(id + '-head');
                    if(head) head.classList.add('selected-edit');
                }
            }
        }

        // H√†m ƒë∆∞·ª£c g·ªçi khi user thay ƒë·ªïi input m√†u/size
        window.updateSelectedFeatureStyle = function() {
            if (!selectedFeatureId) return;
            const feature = mapData.features.find(f => f.id === selectedFeatureId);
            if (!feature) return;

            const color = document.getElementById('draw-color').value;
            const size = document.getElementById('draw-size').value;
            const width = document.getElementById('draw-width').value;

            feature.style.color = color;
            feature.style.size = size;
            feature.style.width = width;

            // Apply changes visually
            if (feature.type === 'arrow') {
                if(map.getLayer(feature.id)) {
                    map.setPaintProperty(feature.id, 'line-color', color);
                    map.setPaintProperty(feature.id, 'line-width', parseInt(width));
                }
                const head = document.getElementById(feature.id + '-head');
                if (head) {
                    const iconSize = parseInt(size) * 6;
                    head.innerHTML = `<i class="fas fa-long-arrow-alt-up" style="color: ${color}; font-size: ${iconSize}px; display:block; text-shadow:0 0 2px white;"></i>`;
                    // Gi·ªØ nguy√™n g√≥c xoay
                    const icon = head.querySelector('i');
                    // C·∫ßn l·∫•y l·∫°i bearing c≈© n·∫øu c√≥
                    // T·∫°m th·ªùi reset rotation transform trong HTML, rotation th·ª±c t·∫ø do logic updateArrowHeadRotation qu·∫£n l√Ω
                }
            } else if (feature.type === 'marker') {
                const el = document.getElementById(feature.id);
                if (el) {
                    const px = parseInt(size) * 8;
                    el.innerHTML = `<i class="fas fa-${feature.data.icon}" style="color:${color}; font-size:${px}px; text-shadow: 1px 1px 1px black;"></i>`;
                }
            } else if (feature.type === 'text') {
                const el = document.getElementById(feature.id);
                if (el) {
                    el.style.color = color;
                    el.style.fontSize = (parseInt(size) * 5) + 'px';
                }
            } else if (feature.type === 'polygon') {
                if(map.getLayer(feature.id + '-fill')) {
                    map.setPaintProperty(feature.id + '-fill', 'fill-color', color);
                }
                if(map.getLayer(feature.id + '-outline')) {
                    map.setPaintProperty(feature.id + '-outline', 'line-color', color);
                }
            }
        }

        map.on('click', (e) => {
            if (isFreehandDrawing) return;
            
            // X·ª≠ l√Ω Click ch·ªçn ƒë·ªÉ s·ª≠a (N·∫øu kh√¥ng v·∫Ω v√† kh√¥ng x√≥a)
            if (!isDrawing && currentDrawType !== 'delete') {
                // Check click map features (Arrows, Polygons)
                const point = e.point;
                // Check arrow click via Layer query
                const arrowFeatures = map.queryRenderedFeatures(point, { layers: mapData.features.filter(f=>f.type==='arrow').map(f=>f.id) });
                if (arrowFeatures.length > 0) {
                    const id = arrowFeatures[0].layer.id;
                    selectFeature(id);
                    return;
                }
                // Check Polygon click
                const polyLayers = mapData.features.filter(f=>f.type==='polygon').map(f=>f.id + '-fill');
                const polyFeatures = map.queryRenderedFeatures(point, { layers: polyLayers });
                if (polyFeatures.length > 0) {
                    const id = polyFeatures[0].layer.id.replace('-fill', '');
                    selectFeature(id);
                    return;
                }
                // Click v√†o ch·ªó tr·ªëng -> B·ªè ch·ªçn
                selectFeature(null);
                return;
            }

            if (currentDrawType === 'delete') { handleDeleteSelection(e); return; }
            if (currentDrawType === 'polygon') return;

            const color = document.getElementById('draw-color').value;
            const size = document.getElementById('draw-size').value;
            const label = document.getElementById('draw-label').value;

            if (currentDrawType === 'marker') {
                const id = 'marker-' + Date.now();
                addIconMarker(e.lngLat, selectedIcon, color, size, label, id);
                saveFeature(id, 'marker', {lng: e.lngLat.lng, lat: e.lngLat.lat, icon: selectedIcon}, {color, size}, label, 0);
                updateMarkerScales();
            }
            else if (currentDrawType === 'text') {
                const text = document.getElementById('text-content').value || "ƒê·ªãa danh";
                const font = document.getElementById('text-font').value;
                const isBold = document.getElementById('text-bold').checked;
                const isItalic = document.getElementById('text-italic').checked;
                const id = 'text-' + Date.now();
                addTextMarker(e.lngLat, text, color, size, font, isBold, isItalic, id);
                saveFeature(id, 'text', {lng: e.lngLat.lng, lat: e.lngLat.lat, text}, {color, size, font, isBold, isItalic}, label, 0);
                updateMarkerScales();
            }
            else if (currentDrawType === 'arrow') {
                currentPoints.push([e.lngLat.lng, e.lngLat.lat]);
                updateTempLayer('line');
            }
        });

        map.on('dblclick', (e) => {
            if(!isDrawing || currentDrawType === 'delete' || currentDrawType === 'polygon') return;
            e.preventDefault();
            const color = document.getElementById('draw-color').value;
            const size = document.getElementById('draw-size').value;
            const width = document.getElementById('draw-width').value;
            let label = document.getElementById('draw-label').value;

            if (currentDrawType === 'arrow' && currentPoints.length > 1) {
                arrowCounter++;
                if(!label) label = `M≈©i ti·∫øn c√¥ng ${arrowCounter}`;
                const dashed = document.getElementById('draw-dashed').checked;
                const id = 'arrow-' + Date.now();
                addArrowToMap(currentPoints, color, size, width, dashed, id, arrowCounter);
                saveFeature(id, 'arrow', currentPoints, {color, size, width, dashed}, label, arrowCounter);
                stopDrawing();
            }
        });

        function finishFreehandPolygon() {
            if (currentPoints.length < 2) return;
            const color = document.getElementById('draw-color').value;
            let label = document.getElementById('draw-label').value || "V√πng ho·∫°t ƒë·ªông";
            const isDashed = document.getElementById('poly-dashed').checked;
            const isFill = document.getElementById('poly-fill').checked;
            const id = 'poly-' + Date.now();
            
            let coords = currentPoints;
            if (isFill) {
                coords.push(coords[0]);
                coords = [coords];
            }
            
            try {
                const tempLine = turf.lineString(currentPoints);
                const simplified = turf.simplify(tempLine, {tolerance: 0.005, highQuality: false});
                let finalGeoCoords = simplified.geometry.coordinates;
                
                if (isFill) {
                     finalGeoCoords.push(finalGeoCoords[0]);
                     coords = [finalGeoCoords];
                     addPolygonToMap(finalGeoCoords, color, 0.5, id, isDashed);
                } else {
                     coords = finalGeoCoords;
                     map.addSource(id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: coords } } });
                     map.addLayer({
                         id: id + '-outline', type: 'line', source: id, 
                         paint: { 'line-color': color, 'line-width': 3, 'line-dasharray': isDashed ? [2, 2] : [1, 0] }
                     });
                }
                saveFeature(id, 'polygon', coords, {color, opacity: 0.5, isDashed, isFill}, label, 0);
            } catch (e) { console.error(e); }
            stopDrawing();
        }

        // --- KEY HANDLERS (Rotate Arrow, Delete X, Bend Z) ---
        document.addEventListener('keydown', (e) => {
            // Delete (X)
            if ((e.key === 'x' || e.key === 'X')) {
                if (currentDrawType === 'delete' && pendingDeleteId) {
                     if (suppressDeleteWarning) executeDelete(); else document.getElementById('delete-confirm-modal').style.display = 'flex';
                } else if (selectedFeatureId) {
                    // Quick delete selected
                    pendingDeleteId = selectedFeatureId;
                    if (suppressDeleteWarning) executeDelete(); else document.getElementById('delete-confirm-modal').style.display = 'flex';
                }
            }
            // Glow (U)
            if (e.key === 'u' || e.key === 'U') {
                const chk = document.getElementById('chk-glow-effect'); chk.checked = !chk.checked; toggleGlowMode();
            }
            // Bend (Z)
            if (e.key === 'z' || e.key === 'Z') isBending = true;
            // Exit (Esc)
            if (e.key === 'Escape') {
                if (currentDrawType === 'delete' || isDrawing) {
                    document.getElementById('draw-mode').value = 'none'; updateUI(); toggleDrawing(); 
                } 
                selectFeature(null);
                document.getElementById('delete-confirm-modal').style.display = 'none';
            }
            // Timeline
            if (e.key.toLowerCase() === 't') changeTimeline(1);
            if (e.key.toLowerCase() === 'y') changeTimeline(-1);
            
            // ROTATE SELECTED OBJECT (Arrow Keys / A-D)
            if (selectedFeatureId) {
                const feature = mapData.features.find(f => f.id === selectedFeatureId);
                if (feature) {
                    // Rotate Icon/Marker head (A/D)
                    if (e.key.toLowerCase() === 'a' || e.key.toLowerCase() === 'd') {
                        const el = document.getElementById(feature.id + (feature.type==='arrow' ? '-head' : ''));
                        if(el) {
                            const icon = el.querySelector('i');
                            if(icon) {
                                let currentRot = 0;
                                const st = window.getComputedStyle(icon);
                                const tm = st.getPropertyValue("-webkit-transform") || st.getPropertyValue("transform");
                                if(tm !== 'none') {
                                    const values = tm.split('(')[1].split(')')[0].split(',');
                                    const a = values[0]; const b = values[1];
                                    currentRot = Math.round(Math.atan2(b, a) * (180/Math.PI));
                                }
                                const step = e.key.toLowerCase() === 'a' ? -5 : 5;
                                icon.style.transform = `rotate(${currentRot + step}deg)`;
                            }
                        }
                    }
                    
                    // REQ: Rotate Entire Arrow (Left/Right Arrow Keys)
                    if (feature.type === 'arrow' && (e.key === 'ArrowLeft' || e.key === 'ArrowRight')) {
                        e.preventDefault();
                        const angle = e.key === 'ArrowLeft' ? -5 : 5;
                        const lineString = turf.lineString(feature.data);
                        const rotated = turf.transformRotate(lineString, angle);
                        const newCoords = rotated.geometry.coordinates;
                        
                        // Update Data
                        feature.data = newCoords;
                        // Update Map Source
                        map.getSource(feature.id).setData({ type: 'Feature', geometry: { type: 'LineString', coordinates: newCoords } });
                        
                        // Update Head Position
                        const last = newCoords[newCoords.length - 1];
                        const prev = newCoords[newCoords.length - 2];
                        const bearing = turf.bearing(turf.point(prev), turf.point(last));
                        
                        const markerInstance = feature.markerInstance; // Need reference? No, we can select DOM
                        // We need to move the marker using setLngLat. But we don't store marker instance in mapData easily.
                        // However, we can re-create marker or find it if we stored it?
                        // Hack: Store marker in mapData temporarily or global lookup?
                        // Easier: remove and re-add arrow head? No visually bad.
                        // Best: Access marker via global lookup or attach to DOM?
                        // Let's assume we redraw or just move DOM? Marker logic binds to map.
                        // Correct way: We need the marker object.
                        // I will add markerInstance to mapData feature object when created.
                    }
                }
            }
        });
        document.addEventListener('keyup', (e) => { if (e.key === 'z' || e.key === 'Z') isBending = false; });

        // Logic Bending (S·ª≠a ƒë∆∞·ªùng cong) + Fix Save
        function handleBending(e) {
            // Ch·ªâ bend khi ƒëang gi·ªØ Z v√† c√≥ ƒë·ªëi t∆∞·ª£ng ch·ªçn
            if (isBending && selectedFeatureId) {
                const feature = mapData.features.find(f => f.id === selectedFeatureId);
                if (feature && feature.type === 'arrow') {
                    const originalCoords = feature.data; // Coordinates hi·ªán t·∫°i
                    const start = originalCoords[0];
                    const end = originalCoords[originalCoords.length - 1];
                    const mouse = [e.lngLat.lng, e.lngLat.lat];
                    const line = turf.lineString([start, mouse, end]);
                    const curved = turf.bezierSpline(line, { resolution: 10000, sharpness: 0.6 });
                    
                    // Update Map
                    map.getSource(feature.id).setData(curved);
                    
                    // CRITICAL FIX: Update mapData with Curved Coords so JSON saves the curve
                    feature.data = curved.geometry.coordinates;
                }
            }
        }

        function updateTempLayer(type) {
            const data = { type: 'Feature', geometry: { type: type === 'line' ? 'LineString' : 'Polygon', coordinates: currentPoints } };
            if (map.getSource(tempId)) { map.getSource(tempId).setData(data); }
            else {
                map.addSource(tempId, { type: 'geojson', data: data });
                map.addLayer({ id: tempId, type: 'line', source: tempId, paint: { 'line-color': '#c0392b', 'line-width': 3 } });
            }
        }

        function addArrowToMap(coords, color, headSize, lineWidth, dashed, id, order) {
            map.addSource(id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: coords } } });
            map.addLayer({
                id: id, type: 'line', source: id,
                layout: { 'line-join': 'round', 'line-cap': 'round' },
                paint: { 'line-color': color, 'line-width': parseInt(lineWidth), 'line-dasharray': dashed ? [2, 2] : [1, 0] }
            });
            const last = coords[coords.length - 1]; const prev = coords[coords.length - 2];
            let bearing = turf.bearing(turf.point(prev), turf.point(last));
            const iconSize = parseInt(headSize) * 6;
            
            const el = document.createElement('div'); 
            el.className = `map-feature feature-arrow arrow-order-${order}`; 
            el.id = id + '-head';
            el.innerHTML = `<i class="fas fa-long-arrow-alt-up" style="color: ${color}; font-size: ${iconSize}px; display:block; text-shadow:0 0 2px white;"></i>`;
            el.style.cursor = 'pointer'; 
            el.querySelector('i').style.transform = `rotate(${bearing}deg)`;
            
            const marker = new maplibregl.Marker({ element: el, rotationAlignment: 'map', pitchAlignment: 'map' }).setLngLat(last).addTo(map);
            
            el.addEventListener('click', (e) => {
                e.stopPropagation();
                selectFeature(id);
            });
            
            return marker;
        }

        function addPolygonToMap(coords, color, opacity, id, isDashed) {
            map.addSource(id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'Polygon', coordinates: [coords] } } });
            // REQ: Polygon ·ªü d∆∞·ªõi l·ªõp cu·ªëi c√πng -> d√πng beforeId.
            // 'layer-separator' l√† l·ªõp background trong su·ªët ta t·∫°o l√∫c init
            map.addLayer({ 
                id: id + '-fill', type: 'fill', source: id, 
                paint: { 'fill-color': color, 'fill-opacity': opacity } 
            }, 'layer-separator'); // Insert before separator? No, separator is bottom. 
            // We want polygon at bottom. MapLibre draws layers in order. 
            // 'vn-border-line' is bottom. We want polygons above border but below arrows.
            // Let's create specific layers order. Or simplest: moveLayer to just above border.
            
            // Fix: D√πng moveLayer sau khi add
            map.moveLayer(id + '-fill', 'vn-border-line'); // ƒê·∫∑t ngay tr√™n bi√™n gi·ªõi
            
            map.addLayer({ 
                id: id + '-outline', type: 'line', source: id, 
                paint: { 'line-color': color, 'line-width': 2, 'line-dasharray': isDashed ? [2, 2] : [1, 0] } 
            }, 'vn-border-line'); // Outline c≈©ng v·∫≠y
        }

        function addIconMarker(lngLat, icon, color, size, label, id) {
            const el = document.createElement('div'); el.className = `map-feature`; el.id = id;
            const px = parseInt(size) * 8; el.innerHTML = `<i class="fas fa-${icon}" style="color:${color}; font-size:${px}px; text-shadow: 1px 1px 1px black;"></i>`;
            const marker = new maplibregl.Marker({ element: el }).setLngLat(lngLat).addTo(map);
            // Apply scale
            const currentZoom = map.getZoom();
            const scaleFactor = Math.max(0.5, Math.pow(1.3, currentZoom - 7.2));
            el.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;

            el.addEventListener('click', (e) => { 
                e.stopPropagation(); 
                selectFeature(id);
            });
            return marker;
        }

        function addTextMarker(lngLat, text, color, size, font, bold, italic, id) {
            const el = document.createElement('div'); el.className = `custom-text-marker`; el.id = id;
            el.style.color = color; el.style.fontSize = (parseInt(size) * 5) + 'px'; el.style.fontFamily = font; el.style.fontWeight = bold ? 'bold' : 'normal'; el.style.fontStyle = italic ? 'italic' : 'normal'; el.innerText = text; el.style.cursor = 'pointer';
            const marker = new maplibregl.Marker({ element: el }).setLngLat(lngLat).addTo(map);
            
            const currentZoom = map.getZoom();
            const scaleFactor = Math.max(0.5, Math.pow(1.3, currentZoom - 7.2));
            el.style.transform = `translate(-50%, -50%) scale(${scaleFactor})`;

            el.addEventListener('click', (e) => { e.stopPropagation(); selectFeature(id); });
            return marker;
        }

        // --- DATA MANAGEMENT ---
        function saveFeature(id, type, data, style, label, order, markerInstance = null) {
            const feat = { id, type, data, style, label, order };
            if(markerInstance) feat.markerInstance = markerInstance; // Store ref for rotation logic if possible (Note: can't stringify circular struct)
            // We just push basic data to array. Marker instance is transient.
            // For rotation logic we need to look up marker from Map object or global array.
            // Let's verify existing id
            const existingIdx = mapData.features.findIndex(f => f.id === id);
            if (existingIdx > -1) {
                mapData.features[existingIdx] = feat; // Update
            } else {
                mapData.features.push(feat);
            }
            renderTimelineTable();
        }

        function renderTimelineTable() {
            const tbody = document.getElementById('timeline-list'); tbody.innerHTML = '';
            const arrows = mapData.features.filter(f => f.type === 'arrow').sort((a,b) => a.order - b.order);
            arrows.forEach(feat => {
                const tr = document.createElement('tr');
                tr.innerHTML = `
                    <td align="center"><input type="number" class="order-input" value="${feat.order}" onchange="updateFeatureOrder('${feat.id}', this.value)"></td>
                    <td><input type="text" class="name-input" value="${feat.label}" onchange="updateFeatureLabel('${feat.id}', this.value)"></td>
                    <td align="center"><i class="fas fa-trash" style="cursor:pointer; color:#e74c3c;" onclick="confirmDeleteFromTable('${feat.id}')"></i></td>
                `;
                tbody.appendChild(tr);
            });
            updateVisibility();
        }
        window.updateFeatureOrder = function(id, newOrderVal) {
            let newOrder = parseInt(newOrderVal); if(isNaN(newOrder) || newOrder < 0) newOrder = 0;
            const feature = mapData.features.find(f => f.id === id);
            if(feature) { feature.order = newOrder; if(newOrder > arrowCounter) arrowCounter = newOrder; renderTimelineTable(); }
        }
        window.updateFeatureLabel = function(id, newLabel) {
            const feature = mapData.features.find(f => f.id === id);
            if(feature) { feature.label = newLabel; }
        }
        function confirmDeleteFromTable(id) { pendingDeleteId = id; if (suppressDeleteWarning) executeDelete(); else document.getElementById('delete-confirm-modal').style.display = 'flex'; }
        function deleteFeature(id) {
            if(map.getLayer(id)) map.removeLayer(id); if(map.getLayer(id+'-fill')) map.removeLayer(id+'-fill'); if(map.getLayer(id+'-outline')) map.removeLayer(id+'-outline'); if(map.getSource(id)) map.removeSource(id);
            const el = document.getElementById(id); if(el) el.remove(); const headEl = document.getElementById(id+'-head'); if(headEl) headEl.remove();
            mapData.features = mapData.features.filter(f => f.id !== id); 
            if(selectedFeatureId === id) selectFeature(null);
            renderTimelineTable();
        }
        function changeTimeline(val) {
            if (currentTimelineStep === 999 && val === 1) currentTimelineStep = 0; 
            currentTimelineStep += val; if (currentTimelineStep < 0) currentTimelineStep = 0; 
            if (currentTimelineStep > arrowCounter + 5) currentTimelineStep = 999;
            document.getElementById('current-step-display').innerText = currentTimelineStep === 999 ? "Hi·ªán t·∫•t c·∫£" : `B∆∞·ªõc: ${currentTimelineStep}`;
            updateVisibility();
        }
        function showAllTimeline() { currentTimelineStep = 999; document.getElementById('current-step-display').innerText = "Hi·ªán t·∫•t c·∫£"; updateVisibility(); }
        function toggleGlowMode() { isGlowingEnabled = document.getElementById('chk-glow-effect').checked; updateVisibility(); }
        function updateVisibility() {
            mapData.features.forEach(feat => {
                const step = feat.order;
                const isVisible = (currentTimelineStep === 999) || (step <= currentTimelineStep);
                if(feat.type === 'arrow') {
                    if (map.getLayer(feat.id)) map.setLayoutProperty(feat.id, 'visibility', isVisible ? 'visible' : 'none');
                    const head = document.getElementById(feat.id + '-head');
                    if(head) head.style.display = isVisible ? 'block' : 'none';
                    if (head && map.getLayer(feat.id)) {
                        head.classList.remove('feature-dimmed');
                        if (isGlowingEnabled && currentTimelineStep !== 999 && isVisible) {
                            if (step !== currentTimelineStep) {
                                head.classList.add('feature-dimmed');
                                map.setPaintProperty(feat.id, 'line-color', '#555555'); map.setPaintProperty(feat.id, 'line-opacity', 0.4);
                            } else {
                                map.setPaintProperty(feat.id, 'line-color', feat.style.color); map.setPaintProperty(feat.id, 'line-opacity', 1);
                            }
                        } else {
                            map.setPaintProperty(feat.id, 'line-color', feat.style.color); map.setPaintProperty(feat.id, 'line-opacity', 1);
                        }
                    }
                }
            });
        }

        // --- LEGEND & IMPORT/EXPORT ---
        function createStaticLegend() {
            const container = document.getElementById('static-legend-container');
            const items = [
                { icon: '<i class="fas fa-fire" style="color:#e67e22"></i>', text: 'N∆°i L√™ L·ª£i d·ª±ng c·ªù', type: 'marker', color: '#e67e22', iconName: 'fire' },
                { icon: '<i class="fas fa-mountain" style="color:#5d4037"></i> <i class="fas fa-long-arrow-alt-right" style="color:#c0392b; border-bottom: 2px dashed #c0392b"></i>', text: 'Nghƒ©a qu√¢n r√∫t l√™n n√∫i', type: 'arrow', color: '#c0392b', dashed: true },
                { icon: '<i class="fas fa-long-arrow-alt-right" style="color:#c0392b; transform: rotate(-45deg);"></i>', text: 'H∆∞·ªõng ti·∫øn c·ªßa nghƒ©a qu√¢n', type: 'arrow', color: '#c0392b', dashed: false },
                { icon: '<i class="fas fa-location-arrow" style="color:#c0392b"></i>', text: 'Nghƒ©a qu√¢n ch·∫∑n ƒë√°nh', type: 'marker', color: '#c0392b', iconName: 'location-arrow' },
                { icon: '<i class="fas fa-times" style="color:#c0392b"></i>', text: 'N∆°i ti√™u di·ªát ƒë·ªãch', type: 'marker', color: '#c0392b', iconName: 'times' },
                { icon: '<i class="fas fa-star" style="color:#f1c40f"></i>', text: 'N∆°i ƒë√°nh b·∫°i qu√¢n Minh', type: 'marker', color: '#f1c40f', iconName: 'star' },
                { icon: '<i class="fas fa-chess-rook" style="color:#7f8c8d"></i>', text: 'Th√†nh qu√¢n Minh b·ªã v√¢y', type: 'marker', color: '#7f8c8d', iconName: 'chess-rook' },
                { icon: '<i class="fas fa-long-arrow-alt-right" style="color:#2980b9; border-bottom:2px dashed #2980b9;"></i>', text: 'Qu√¢n Minh r√∫t ch·∫°y', type: 'arrow', color: '#2980b9', dashed: true },
                { icon: '<div style="width:14px;height:14px;background:#eab676;opacity:0.8;border:1px solid #d35400"></div>', text: 'V√πng ho·∫°t ƒë·ªông 1418-1423', type: 'polygon', color: '#eab676', dashed: false },
                { icon: '<div style="width:14px;height:14px;background:#a2d9a2;opacity:0.8;border:1px solid #27ae60"></div>', text: 'V√πng gi·∫£i ph√≥ng 1424-1425', type: 'polygon', color: '#a2d9a2', dashed: false },
                { icon: '<div style="width:14px;height:14px;background:#c3e6cb;opacity:0.8;border:1px solid #2ecc71"></div>', text: 'V√πng gi·∫£i ph√≥ng 1426-1427', type: 'polygon', color: '#c3e6cb', dashed: false },
                { icon: '<div style="width:20px;height:0px;border-top:2px dashed #000;"></div>', text: 'Bi√™n gi·ªõi qu·ªëc gia', type: 'none', color: '#000' }
            ];
            items.forEach(item => {
                const div = document.createElement('div'); div.className = 'legend-row';
                div.innerHTML = `<div class="l-icon">${item.icon}</div><div class="l-text">${item.text}</div>`;
                if(item.type !== 'none') {
                    div.title = "Click ƒë·ªÉ ch·ªçn v·∫Ω lo·∫°i n√†y";
                    div.onclick = () => {
                        document.getElementById('draw-mode').value = item.type; document.getElementById('draw-color').value = item.color;
                        if(item.type === 'arrow') document.getElementById('draw-dashed').checked = item.dashed;
                        if(item.type === 'marker') selectIcon(item.iconName);
                        updateUI(); if(!isDrawing) toggleDrawing();
                    };
                }
                container.appendChild(div);
            });
        }
        function toggleLegend() { const leg = document.getElementById('floating-legend'); const icon = document.getElementById('legend-icon'); leg.classList.toggle('minimized'); icon.className = leg.classList.contains('minimized') ? "fas fa-chevron-up" : "fas fa-chevron-down"; }
        function toggleMapLabels() {
            let labelsVisible = document.getElementById('label-toggle-btn').style.color !== 'rgb(170, 170, 170)'; labelsVisible = !labelsVisible;
            const btn = document.getElementById('label-toggle-btn'); btn.innerHTML = labelsVisible ? '<i class="fas fa-font"></i>' : '<i class="fas fa-slash"></i>'; btn.style.color = labelsVisible ? 'white' : '#aaa';
            const layers = map.getStyle().layers; layers.forEach(layer => { if (layer.type === 'symbol') map.setLayoutProperty(layer.id, 'visibility', labelsVisible ? 'visible' : 'none'); });
        }
        function selectIcon(name) { selectedIcon = name; document.querySelectorAll('.icon-option').forEach(el=>el.classList.remove('selected')); event.currentTarget.classList.add('selected'); }
        function exportJSON() { const blob = new Blob([JSON.stringify(mapData)], {type: "application/json"}); const link = document.createElement('a'); link.href = URL.createObjectURL(blob); link.download = "tactical_map_v13.json"; link.click(); }
        function importJSON(input) {
            const file = input.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = JSON.parse(e.target.result);
                    mapData.features.forEach(f => deleteFeature(f.id));
                    mapData = { features: [] }; arrowCounter = 0;
                    data.features.forEach(f => {
                        if (f.order > arrowCounter) arrowCounter = f.order;
                        if (f.type === 'arrow') {
                            const marker = addArrowToMap(f.data, f.style.color, f.style.size, f.style.width || 4, f.style.dashed, f.id, f.order);
                            saveFeature(f.id, 'arrow', f.data, f.style, f.label, f.order, marker);
                        } else if (f.type === 'marker') {
                            addIconMarker({lng: f.data.lng, lat: f.data.lat}, f.data.icon, f.style.color, f.style.size, f.label, f.id);
                            saveFeature(f.id, 'marker', f.data, f.style, f.label, 0);
                        } else if (f.type === 'text') {
                            if(f.data && f.data.lng) {
                                addTextMarker({lng: f.data.lng, lat: f.data.lat}, f.data.text, f.style.color, f.style.size, f.style.font, f.style.isBold, f.style.isItalic, f.id);
                                saveFeature(f.id, 'text', f.data, f.style, f.label, 0);
                            }
                        } else if (f.type === 'polygon') {
                            if (f.style.isFill) {
                                let inputCoords = f.data;
                                if(Array.isArray(f.data) && Array.isArray(f.data[0]) && Array.isArray(f.data[0][0])) inputCoords = f.data[0];
                                addPolygonToMap(inputCoords, f.style.color, f.style.opacity, f.id, f.style.isDashed);
                            } else {
                                map.addSource(f.id, { type: 'geojson', data: { type: 'Feature', geometry: { type: 'LineString', coordinates: f.data } } });
                                map.addLayer({ id: f.id + '-outline', type: 'line', source: f.id, paint: { 'line-color': f.style.color, 'line-width': 3, 'line-dasharray': f.style.isDashed ? [2, 2] : [1, 0] } });
                            }
                            saveFeature(f.id, 'polygon', f.data, f.style, f.label, 0);
                        }
                    });
                    setTimeout(updateMarkerScales, 100); alert("ƒê√£ t·∫£i b·∫£n ƒë·ªì th√†nh c√¥ng!");
                } catch (err) { console.error(err); alert("L·ªói file kh√¥ng ƒë√∫ng ƒë·ªãnh d·∫°ng."); }
            };
            reader.readAsText(file); input.value = '';
        }
    </script>
</body>
</html>
